
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>xdg_shell</title>

    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="&#x2f;wayland-protocol-docs/main.css"></link>
     
  </head>
  <body class="bg-near-white black-70 sans-serif pa2 ph6-l">

    <a href="&#x2f;wayland-protocol-docs/" class="f4 link near-black dim lh-title">
      Home
    </a>

    

    <div id="content">
      
  <div class="fl w-25 ph2">
    

<div>
  <ul class="list pl0">
  
    <li>
      <a href="#i:xdg_wm_base" class="link blue underline-hover lh-copy">xdg_wm_base</a>
      <ul class="list">
        
        <li>
          <a href="#r:xdg_wm_base:destroy" class="link blue underline-hover lh-copy">destroy</a>
        </li>
        
        <li>
          <a href="#r:xdg_wm_base:create_positioner" class="link blue underline-hover lh-copy">create_positioner</a>
        </li>
        
        <li>
          <a href="#r:xdg_wm_base:get_xdg_surface" class="link blue underline-hover lh-copy">get_xdg_surface</a>
        </li>
        
        <li>
          <a href="#r:xdg_wm_base:pong" class="link blue underline-hover lh-copy">pong</a>
        </li>
        
      </ul>
    </li>
  
    <li>
      <a href="#i:xdg_positioner" class="link blue underline-hover lh-copy">xdg_positioner</a>
      <ul class="list">
        
        <li>
          <a href="#r:xdg_positioner:destroy" class="link blue underline-hover lh-copy">destroy</a>
        </li>
        
        <li>
          <a href="#r:xdg_positioner:set_size" class="link blue underline-hover lh-copy">set_size</a>
        </li>
        
        <li>
          <a href="#r:xdg_positioner:set_anchor_rect" class="link blue underline-hover lh-copy">set_anchor_rect</a>
        </li>
        
        <li>
          <a href="#r:xdg_positioner:set_anchor" class="link blue underline-hover lh-copy">set_anchor</a>
        </li>
        
        <li>
          <a href="#r:xdg_positioner:set_gravity" class="link blue underline-hover lh-copy">set_gravity</a>
        </li>
        
        <li>
          <a href="#r:xdg_positioner:set_constraint_adjustment" class="link blue underline-hover lh-copy">set_constraint_adjustment</a>
        </li>
        
        <li>
          <a href="#r:xdg_positioner:set_offset" class="link blue underline-hover lh-copy">set_offset</a>
        </li>
        
      </ul>
    </li>
  
    <li>
      <a href="#i:xdg_surface" class="link blue underline-hover lh-copy">xdg_surface</a>
      <ul class="list">
        
        <li>
          <a href="#r:xdg_surface:destroy" class="link blue underline-hover lh-copy">destroy</a>
        </li>
        
        <li>
          <a href="#r:xdg_surface:get_toplevel" class="link blue underline-hover lh-copy">get_toplevel</a>
        </li>
        
        <li>
          <a href="#r:xdg_surface:get_popup" class="link blue underline-hover lh-copy">get_popup</a>
        </li>
        
        <li>
          <a href="#r:xdg_surface:set_window_geometry" class="link blue underline-hover lh-copy">set_window_geometry</a>
        </li>
        
        <li>
          <a href="#r:xdg_surface:ack_configure" class="link blue underline-hover lh-copy">ack_configure</a>
        </li>
        
      </ul>
    </li>
  
    <li>
      <a href="#i:xdg_toplevel" class="link blue underline-hover lh-copy">xdg_toplevel</a>
      <ul class="list">
        
        <li>
          <a href="#r:xdg_toplevel:destroy" class="link blue underline-hover lh-copy">destroy</a>
        </li>
        
        <li>
          <a href="#r:xdg_toplevel:set_parent" class="link blue underline-hover lh-copy">set_parent</a>
        </li>
        
        <li>
          <a href="#r:xdg_toplevel:set_title" class="link blue underline-hover lh-copy">set_title</a>
        </li>
        
        <li>
          <a href="#r:xdg_toplevel:set_app_id" class="link blue underline-hover lh-copy">set_app_id</a>
        </li>
        
        <li>
          <a href="#r:xdg_toplevel:show_window_menu" class="link blue underline-hover lh-copy">show_window_menu</a>
        </li>
        
        <li>
          <a href="#r:xdg_toplevel:move" class="link blue underline-hover lh-copy">move</a>
        </li>
        
        <li>
          <a href="#r:xdg_toplevel:resize" class="link blue underline-hover lh-copy">resize</a>
        </li>
        
        <li>
          <a href="#r:xdg_toplevel:set_max_size" class="link blue underline-hover lh-copy">set_max_size</a>
        </li>
        
        <li>
          <a href="#r:xdg_toplevel:set_min_size" class="link blue underline-hover lh-copy">set_min_size</a>
        </li>
        
        <li>
          <a href="#r:xdg_toplevel:set_maximized" class="link blue underline-hover lh-copy">set_maximized</a>
        </li>
        
        <li>
          <a href="#r:xdg_toplevel:unset_maximized" class="link blue underline-hover lh-copy">unset_maximized</a>
        </li>
        
        <li>
          <a href="#r:xdg_toplevel:set_fullscreen" class="link blue underline-hover lh-copy">set_fullscreen</a>
        </li>
        
        <li>
          <a href="#r:xdg_toplevel:unset_fullscreen" class="link blue underline-hover lh-copy">unset_fullscreen</a>
        </li>
        
        <li>
          <a href="#r:xdg_toplevel:set_minimized" class="link blue underline-hover lh-copy">set_minimized</a>
        </li>
        
      </ul>
    </li>
  
    <li>
      <a href="#i:xdg_popup" class="link blue underline-hover lh-copy">xdg_popup</a>
      <ul class="list">
        
        <li>
          <a href="#r:xdg_popup:destroy" class="link blue underline-hover lh-copy">destroy</a>
        </li>
        
        <li>
          <a href="#r:xdg_popup:grab" class="link blue underline-hover lh-copy">grab</a>
        </li>
        
      </ul>
    </li>
  
  </ul>
</div>
  </div>
  <div class="fl w-75 ph2">
    <h1 class="f1 lh-title">xdg_shell</h1>
    <ul class="list pl0">
      
      <li class="mt2">
        <div class="f2 lh-copy" id="i:xdg_wm_base">
          xdg_wm_base
        </div>
        <div class="f6 lh-copy ws-pre-line courier">The xdg_wm_base interface is exposed as a global object enabling clients
to turn their wl_surfaces into windows in a desktop environment. It
defines the basic functionality needed for clients and the compositor to
create windows that can be dragged, resized, maximized, etc, as well as
creating transient windows such as popup menus.
</div>
        <ul class="list pl0">
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_wm_base:destroy">
              destroy
            </div>
            <div class="f5 lh-copy mv1 courier">
              destroy xdg_wm_base
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_wm_base_destroy</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_wm_base*</span> xdg_wm_base</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Destroy this xdg_wm_base object.

Destroying a bound xdg_wm_base object while there are surfaces
still alive created by this xdg_wm_base object instance is illegal
and will result in a protocol error.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_wm_base:create_positioner">
              create_positioner
            </div>
            <div class="f5 lh-copy mv1 courier">
              create a positioner object
            </div>
            
<div class="f6 lh-copy courier">
  <span>struct xdg_positioner* </span><span class="dark-blue">xdg_wm_base_create_positioner</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_wm_base*</span> xdg_wm_base</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Create a positioner object. A positioner object is used to position
surfaces relative to some parent surface. See the interface description
and xdg_surface.get_popup for details.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_wm_base:get_xdg_surface">
              get_xdg_surface
            </div>
            <div class="f5 lh-copy mv1 courier">
              create a shell surface from a surface
            </div>
            
<div class="f6 lh-copy courier">
  <span>struct xdg_surface* </span><span class="dark-blue">xdg_wm_base_get_xdg_surface</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_wm_base*</span> xdg_wm_base,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> surface</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">This creates an xdg_surface for the given surface. While xdg_surface
itself is not a role, the corresponding surface may only be assigned
a role extending xdg_surface, such as xdg_toplevel or xdg_popup.

This creates an xdg_surface for the given surface. An xdg_surface is
used as basis to define a role to a given surface, such as xdg_toplevel
or xdg_popup. It also manages functionality shared between xdg_surface
based surface roles.

See the documentation of xdg_surface for more details about what an
xdg_surface is and how it is used.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_wm_base:pong">
              pong
            </div>
            <div class="f5 lh-copy mv1 courier">
              respond to a ping event
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_wm_base_pong</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_wm_base*</span> xdg_wm_base,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> serial</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">A client must respond to a ping event with a pong request or
the client may be deemed unresponsive. See xdg_wm_base.ping.
  </div>
          </li>
          
        </ul>
      </li>
      
      <li class="mt2">
        <div class="f2 lh-copy" id="i:xdg_positioner">
          xdg_positioner
        </div>
        <div class="f6 lh-copy ws-pre-line courier">The xdg_positioner provides a collection of rules for the placement of a
child surface relative to a parent surface. Rules can be defined to ensure
the child surface remains within the visible area&#x27;s borders, and to
specify how the child surface changes its position, such as sliding along
an axis, or flipping around a rectangle. These positioner-created rules are
constrained by the requirement that a child surface must intersect with or
be at least partially adjacent to its parent surface.

See the various requests for details about possible rules.

At the time of the request, the compositor makes a copy of the rules
specified by the xdg_positioner. Thus, after the request is complete the
xdg_positioner object can be destroyed or reused; further changes to the
object will have no effect on previous usages.

For an xdg_positioner object to be considered complete, it must have a
non-zero size set by set_size, and a non-zero anchor rectangle set by
set_anchor_rect. Passing an incomplete xdg_positioner object when
positioning a surface raises an error.
</div>
        <ul class="list pl0">
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_positioner:destroy">
              destroy
            </div>
            <div class="f5 lh-copy mv1 courier">
              destroy the xdg_positioner object
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_positioner_destroy</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_positioner*</span> xdg_positioner</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Notify the compositor that the xdg_positioner will no longer be used.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_positioner:set_size">
              set_size
            </div>
            <div class="f5 lh-copy mv1 courier">
              set the size of the to-be positioned rectangle
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_positioner_set_size</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_positioner*</span> xdg_positioner,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> width,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> height</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Set the size of the surface that is to be positioned with the positioner
object. The size is in surface-local coordinates and corresponds to the
window geometry. See xdg_surface.set_window_geometry.

If a zero or negative size is set the invalid_input error is raised.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_positioner:set_anchor_rect">
              set_anchor_rect
            </div>
            <div class="f5 lh-copy mv1 courier">
              set the anchor rectangle within the parent surface
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_positioner_set_anchor_rect</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_positioner*</span> xdg_positioner,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> x,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> y,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> width,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> height</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Specify the anchor rectangle within the parent surface that the child
surface will be placed relative to. The rectangle is relative to the
window geometry as defined by xdg_surface.set_window_geometry of the
parent surface.

When the xdg_positioner object is used to position a child surface, the
anchor rectangle may not extend outside the window geometry of the
positioned child&#x27;s parent surface.

If a negative size is set the invalid_input error is raised.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_positioner:set_anchor">
              set_anchor
            </div>
            <div class="f5 lh-copy mv1 courier">
              set anchor rectangle anchor
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_positioner_set_anchor</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_positioner*</span> xdg_positioner,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> anchor</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Defines the anchor point for the anchor rectangle. The specified anchor
is used derive an anchor point that the child surface will be
positioned relative to. If a corner anchor is set (e.g. &#x27;top_left&#x27; or
&#x27;bottom_right&#x27;), the anchor point will be at the specified corner;
otherwise, the derived anchor point will be centered on the specified
edge, or in the center of the anchor rectangle if no edge is specified.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_positioner:set_gravity">
              set_gravity
            </div>
            <div class="f5 lh-copy mv1 courier">
              set child surface gravity
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_positioner_set_gravity</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_positioner*</span> xdg_positioner,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> gravity</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Defines in what direction a surface should be positioned, relative to
the anchor point of the parent surface. If a corner gravity is
specified (e.g. &#x27;bottom_right&#x27; or &#x27;top_left&#x27;), then the child surface
will be placed towards the specified gravity; otherwise, the child
surface will be centered over the anchor point on any axis that had no
gravity specified.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_positioner:set_constraint_adjustment">
              set_constraint_adjustment
            </div>
            <div class="f5 lh-copy mv1 courier">
              set the adjustment to be done when constrained
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_positioner_set_constraint_adjustment</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_positioner*</span> xdg_positioner,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> constraint_adjustment</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Specify how the window should be positioned if the originally intended
position caused the surface to be constrained, meaning at least
partially outside positioning boundaries set by the compositor. The
adjustment is set by constructing a bitmask describing the adjustment to
be made when the surface is constrained on that axis.

If no bit for one axis is set, the compositor will assume that the child
surface should not change its position on that axis when constrained.

If more than one bit for one axis is set, the order of how adjustments
are applied is specified in the corresponding adjustment descriptions.

The default adjustment is none.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_positioner:set_offset">
              set_offset
            </div>
            <div class="f5 lh-copy mv1 courier">
              set surface position offset
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_positioner_set_offset</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_positioner*</span> xdg_positioner,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> x,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> y</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Specify the surface position offset relative to the position of the
anchor on the anchor rectangle and the anchor on the surface. For
example if the anchor of the anchor rectangle is at (x, y), the surface
has the gravity bottom|right, and the offset is (ox, oy), the calculated
surface position will be (x + ox, y + oy). The offset position of the
surface is the one used for constraint testing. See
set_constraint_adjustment.

An example use case is placing a popup menu on top of a user interface
element, while aligning the user interface element of the parent surface
with some user interface element placed somewhere in the popup surface.
  </div>
          </li>
          
        </ul>
      </li>
      
      <li class="mt2">
        <div class="f2 lh-copy" id="i:xdg_surface">
          xdg_surface
        </div>
        <div class="f6 lh-copy ws-pre-line courier">An interface that may be implemented by a wl_surface, for
implementations that provide a desktop-style user interface.

It provides a base set of functionality required to construct user
interface elements requiring management by the compositor, such as
toplevel windows, menus, etc. The types of functionality are split into
xdg_surface roles.

Creating an xdg_surface does not set the role for a wl_surface. In order
to map an xdg_surface, the client must create a role-specific object
using, e.g., get_toplevel, get_popup. The wl_surface for any given
xdg_surface can have at most one role, and may not be assigned any role
not based on xdg_surface.

A role must be assigned before any other requests are made to the
xdg_surface object.

The client must call wl_surface.commit on the corresponding wl_surface
for the xdg_surface state to take effect.

Creating an xdg_surface from a wl_surface which has a buffer attached or
committed is a client error, and any attempts by a client to attach or
manipulate a buffer prior to the first xdg_surface.configure call must
also be treated as errors.

Mapping an xdg_surface-based role surface is defined as making it
possible for the surface to be shown by the compositor. Note that
a mapped surface is not guaranteed to be visible once it is mapped.

For an xdg_surface to be mapped by the compositor, the following
conditions must be met:
(1) the client has assigned an xdg_surface-based role to the surface
(2) the client has set and committed the xdg_surface state and the
role-dependent state to the surface
(3) the client has committed a buffer to the surface

A newly-unmapped surface is considered to have met condition (1) out
of the 3 required conditions for mapping a surface if its role surface
has not been destroyed.
</div>
        <ul class="list pl0">
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_surface:destroy">
              destroy
            </div>
            <div class="f5 lh-copy mv1 courier">
              destroy the xdg_surface
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_surface_destroy</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_surface*</span> xdg_surface</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Destroy the xdg_surface object. An xdg_surface must only be destroyed
after its role object has been destroyed.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_surface:get_toplevel">
              get_toplevel
            </div>
            <div class="f5 lh-copy mv1 courier">
              assign the xdg_toplevel surface role
            </div>
            
<div class="f6 lh-copy courier">
  <span>struct xdg_toplevel* </span><span class="dark-blue">xdg_surface_get_toplevel</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_surface*</span> xdg_surface</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">This creates an xdg_toplevel object for the given xdg_surface and gives
the associated wl_surface the xdg_toplevel role.

See the documentation of xdg_toplevel for more details about what an
xdg_toplevel is and how it is used.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_surface:get_popup">
              get_popup
            </div>
            <div class="f5 lh-copy mv1 courier">
              assign the xdg_popup surface role
            </div>
            
<div class="f6 lh-copy courier">
  <span>struct xdg_popup* </span><span class="dark-blue">xdg_surface_get_popup</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_surface*</span> xdg_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_surface*</span> parent,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_positioner*</span> positioner</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">This creates an xdg_popup object for the given xdg_surface and gives
the associated wl_surface the xdg_popup role.

If null is passed as a parent, a parent surface must be specified using
some other protocol, before committing the initial state.

See the documentation of xdg_popup for more details about what an
xdg_popup is and how it is used.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_surface:set_window_geometry">
              set_window_geometry
            </div>
            <div class="f5 lh-copy mv1 courier">
              set the new window geometry
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_surface_set_window_geometry</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_surface*</span> xdg_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> x,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> y,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> width,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> height</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">The window geometry of a surface is its &quot;visible bounds&quot; from the
user&#x27;s perspective. Client-side decorations often have invisible
portions like drop-shadows which should be ignored for the
purposes of aligning, placing and constraining windows.

The window geometry is double buffered, and will be applied at the
time wl_surface.commit of the corresponding wl_surface is called.

When maintaining a position, the compositor should treat the (x, y)
coordinate of the window geometry as the top left corner of the window.
A client changing the (x, y) window geometry coordinate should in
general not alter the position of the window.

Once the window geometry of the surface is set, it is not possible to
unset it, and it will remain the same until set_window_geometry is
called again, even if a new subsurface or buffer is attached.

If never set, the value is the full bounds of the surface,
including any subsurfaces. This updates dynamically on every
commit. This unset is meant for extremely simple clients.

The arguments are given in the surface-local coordinate space of
the wl_surface associated with this xdg_surface.

The width and height must be greater than zero. Setting an invalid size
will raise an error. When applied, the effective window geometry will be
the set window geometry clamped to the bounding rectangle of the
combined geometry of the surface of the xdg_surface and the associated
subsurfaces.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_surface:ack_configure">
              ack_configure
            </div>
            <div class="f5 lh-copy mv1 courier">
              ack a configure event
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_surface_ack_configure</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_surface*</span> xdg_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> serial</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">When a configure event is received, if a client commits the
surface in response to the configure event, then the client
must make an ack_configure request sometime before the commit
request, passing along the serial of the configure event.

For instance, for toplevel surfaces the compositor might use this
information to move a surface to the top left only when the client has
drawn itself for the maximized or fullscreen state.

If the client receives multiple configure events before it
can respond to one, it only has to ack the last configure event.

A client is not required to commit immediately after sending
an ack_configure request - it may even ack_configure several times
before its next surface commit.

A client may send multiple ack_configure requests before committing, but
only the last request sent before a commit indicates which configure
event the client really is responding to.
  </div>
          </li>
          
        </ul>
      </li>
      
      <li class="mt2">
        <div class="f2 lh-copy" id="i:xdg_toplevel">
          xdg_toplevel
        </div>
        <div class="f6 lh-copy ws-pre-line courier">This interface defines an xdg_surface role which allows a surface to,
among other things, set window-like properties such as maximize,
fullscreen, and minimize, set application-specific metadata like title and
id, and well as trigger user interactive operations such as interactive
resize and move.

Unmapping an xdg_toplevel means that the surface cannot be shown
by the compositor until it is explicitly mapped again.
All active operations (e.g., move, resize) are canceled and all
attributes (e.g. title, state, stacking, ...) are discarded for
an xdg_toplevel surface when it is unmapped.

Attaching a null buffer to a toplevel unmaps the surface.
</div>
        <ul class="list pl0">
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_toplevel:destroy">
              destroy
            </div>
            <div class="f5 lh-copy mv1 courier">
              destroy the xdg_toplevel
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_toplevel_destroy</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> xdg_toplevel</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">This request destroys the role surface and unmaps the surface;
see &quot;Unmapping&quot; behavior in interface section for details.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_toplevel:set_parent">
              set_parent
            </div>
            <div class="f5 lh-copy mv1 courier">
              set the parent of this surface
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_toplevel_set_parent</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> xdg_toplevel,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> parent</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Set the &quot;parent&quot; of this surface. This surface should be stacked
above the parent surface and all other ancestor surfaces.

Parent windows should be set on dialogs, toolboxes, or other
&quot;auxiliary&quot; surfaces, so that the parent is raised when the dialog
is raised.

Setting a null parent for a child window removes any parent-child
relationship for the child. Setting a null parent for a window which
currently has no parent is a no-op.

If the parent is unmapped then its children are managed as
though the parent of the now-unmapped parent has become the
parent of this surface. If no parent exists for the now-unmapped
parent then the children are managed as though they have no
parent surface.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_toplevel:set_title">
              set_title
            </div>
            <div class="f5 lh-copy mv1 courier">
              set surface title
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_toplevel_set_title</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> xdg_toplevel,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">const char*</span> title</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Set a short title for the surface.

This string may be used to identify the surface in a task bar,
window list, or other user interface elements provided by the
compositor.

The string must be encoded in UTF-8.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_toplevel:set_app_id">
              set_app_id
            </div>
            <div class="f5 lh-copy mv1 courier">
              set application ID
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_toplevel_set_app_id</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> xdg_toplevel,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">const char*</span> app_id</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Set an application identifier for the surface.

The app ID identifies the general class of applications to which
the surface belongs. The compositor can use this to group multiple
surfaces together, or to determine how to launch a new application.

For D-Bus activatable applications, the app ID is used as the D-Bus
service name.

The compositor shell will try to group application surfaces together
by their app ID. As a best practice, it is suggested to select app
ID&#x27;s that match the basename of the application&#x27;s .desktop file.
For example, &quot;org.freedesktop.FooViewer&quot; where the .desktop file is
&quot;org.freedesktop.FooViewer.desktop&quot;.

See the desktop-entry specification [0] for more details on
application identifiers and how they relate to well-known D-Bus
names and .desktop files.

[0] http:&#x2f;&#x2f;standards.freedesktop.org&#x2f;desktop-entry-spec&#x2f;
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_toplevel:show_window_menu">
              show_window_menu
            </div>
            <div class="f5 lh-copy mv1 courier">
              show the window menu
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_toplevel_show_window_menu</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> xdg_toplevel,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_seat*</span> seat,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> serial,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> x,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> y</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Clients implementing client-side decorations might want to show
a context menu when right-clicking on the decorations, giving the
user a menu that they can use to maximize or minimize the window.

This request asks the compositor to pop up such a window menu at
the given position, relative to the local surface coordinates of
the parent surface. There are no guarantees as to what menu items
the window menu contains.

This request must be used in response to some sort of user action
like a button press, key press, or touch down event.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_toplevel:move">
              move
            </div>
            <div class="f5 lh-copy mv1 courier">
              start an interactive move
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_toplevel_move</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> xdg_toplevel,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_seat*</span> seat,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> serial</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Start an interactive, user-driven move of the surface.

This request must be used in response to some sort of user action
like a button press, key press, or touch down event. The passed
serial is used to determine the type of interactive move (touch,
pointer, etc).

The server may ignore move requests depending on the state of
the surface (e.g. fullscreen or maximized), or if the passed serial
is no longer valid.

If triggered, the surface will lose the focus of the device
(wl_pointer, wl_touch, etc) used for the move. It is up to the
compositor to visually indicate that the move is taking place, such as
updating a pointer cursor, during the move. There is no guarantee
that the device focus will return when the move is completed.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_toplevel:resize">
              resize
            </div>
            <div class="f5 lh-copy mv1 courier">
              start an interactive resize
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_toplevel_resize</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> xdg_toplevel,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_seat*</span> seat,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> serial,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> edges</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Start a user-driven, interactive resize of the surface.

This request must be used in response to some sort of user action
like a button press, key press, or touch down event. The passed
serial is used to determine the type of interactive resize (touch,
pointer, etc).

The server may ignore resize requests depending on the state of
the surface (e.g. fullscreen or maximized).

If triggered, the client will receive configure events with the
&quot;resize&quot; state enum value and the expected sizes. See the &quot;resize&quot;
enum value for more details about what is required. The client
must also acknowledge configure events using &quot;ack_configure&quot;. After
the resize is completed, the client will receive another &quot;configure&quot;
event without the resize state.

If triggered, the surface also will lose the focus of the device
(wl_pointer, wl_touch, etc) used for the resize. It is up to the
compositor to visually indicate that the resize is taking place,
such as updating a pointer cursor, during the resize. There is no
guarantee that the device focus will return when the resize is
completed.

The edges parameter specifies how the surface should be resized,
and is one of the values of the resize_edge enum. The compositor
may use this information to update the surface position for
example when dragging the top left corner. The compositor may also
use this information to adapt its behavior, e.g. choose an
appropriate cursor image.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_toplevel:set_max_size">
              set_max_size
            </div>
            <div class="f5 lh-copy mv1 courier">
              set the maximum size
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_toplevel_set_max_size</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> xdg_toplevel,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> width,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> height</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Set a maximum size for the window.

The client can specify a maximum size so that the compositor does
not try to configure the window beyond this size.

The width and height arguments are in window geometry coordinates.
See xdg_surface.set_window_geometry.

Values set in this way are double-buffered. They will get applied
on the next commit.

The compositor can use this information to allow or disallow
different states like maximize or fullscreen and draw accurate
animations.

Similarly, a tiling window manager may use this information to
place and resize client windows in a more effective way.

The client should not rely on the compositor to obey the maximum
size. The compositor may decide to ignore the values set by the
client and request a larger size.

If never set, or a value of zero in the request, means that the
client has no expected maximum size in the given dimension.
As a result, a client wishing to reset the maximum size
to an unspecified state can use zero for width and height in the
request.

Requesting a maximum size to be smaller than the minimum size of
a surface is illegal and will result in a protocol error.

The width and height must be greater than or equal to zero. Using
strictly negative values for width and height will result in a
protocol error.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_toplevel:set_min_size">
              set_min_size
            </div>
            <div class="f5 lh-copy mv1 courier">
              set the minimum size
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_toplevel_set_min_size</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> xdg_toplevel,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> width,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> height</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Set a minimum size for the window.

The client can specify a minimum size so that the compositor does
not try to configure the window below this size.

The width and height arguments are in window geometry coordinates.
See xdg_surface.set_window_geometry.

Values set in this way are double-buffered. They will get applied
on the next commit.

The compositor can use this information to allow or disallow
different states like maximize or fullscreen and draw accurate
animations.

Similarly, a tiling window manager may use this information to
place and resize client windows in a more effective way.

The client should not rely on the compositor to obey the minimum
size. The compositor may decide to ignore the values set by the
client and request a smaller size.

If never set, or a value of zero in the request, means that the
client has no expected minimum size in the given dimension.
As a result, a client wishing to reset the minimum size
to an unspecified state can use zero for width and height in the
request.

Requesting a minimum size to be larger than the maximum size of
a surface is illegal and will result in a protocol error.

The width and height must be greater than or equal to zero. Using
strictly negative values for width and height will result in a
protocol error.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_toplevel:set_maximized">
              set_maximized
            </div>
            <div class="f5 lh-copy mv1 courier">
              maximize the window
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_toplevel_set_maximized</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> xdg_toplevel</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Maximize the surface.

After requesting that the surface should be maximized, the compositor
will respond by emitting a configure event. Whether this configure
actually sets the window maximized is subject to compositor policies.
The client must then update its content, drawing in the configured
state. The client must also acknowledge the configure when committing
the new content (see ack_configure).

It is up to the compositor to decide how and where to maximize the
surface, for example which output and what region of the screen should
be used.

If the surface was already maximized, the compositor will still emit
a configure event with the &quot;maximized&quot; state.

If the surface is in a fullscreen state, this request has no direct
effect. It may alter the state the surface is returned to when
unmaximized unless overridden by the compositor.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_toplevel:unset_maximized">
              unset_maximized
            </div>
            <div class="f5 lh-copy mv1 courier">
              unmaximize the window
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_toplevel_unset_maximized</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> xdg_toplevel</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Unmaximize the surface.

After requesting that the surface should be unmaximized, the compositor
will respond by emitting a configure event. Whether this actually
un-maximizes the window is subject to compositor policies.
If available and applicable, the compositor will include the window
geometry dimensions the window had prior to being maximized in the
configure event. The client must then update its content, drawing it in
the configured state. The client must also acknowledge the configure
when committing the new content (see ack_configure).

It is up to the compositor to position the surface after it was
unmaximized; usually the position the surface had before maximizing, if
applicable.

If the surface was already not maximized, the compositor will still
emit a configure event without the &quot;maximized&quot; state.

If the surface is in a fullscreen state, this request has no direct
effect. It may alter the state the surface is returned to when
unmaximized unless overridden by the compositor.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_toplevel:set_fullscreen">
              set_fullscreen
            </div>
            <div class="f5 lh-copy mv1 courier">
              set the window as fullscreen on an output
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_toplevel_set_fullscreen</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> xdg_toplevel,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_output*</span> output</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Make the surface fullscreen.

After requesting that the surface should be fullscreened, the
compositor will respond by emitting a configure event. Whether the
client is actually put into a fullscreen state is subject to compositor
policies. The client must also acknowledge the configure when
committing the new content (see ack_configure).

The output passed by the request indicates the client&#x27;s preference as
to which display it should be set fullscreen on. If this value is NULL,
it&#x27;s up to the compositor to choose which display will be used to map
this surface.

If the surface doesn&#x27;t cover the whole output, the compositor will
position the surface in the center of the output and compensate with
with border fill covering the rest of the output. The content of the
border fill is undefined, but should be assumed to be in some way that
attempts to blend into the surrounding area (e.g. solid black).

If the fullscreened surface is not opaque, the compositor must make
sure that other screen content not part of the same surface tree (made
up of subsurfaces, popups or similarly coupled surfaces) are not
visible below the fullscreened surface.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_toplevel:unset_fullscreen">
              unset_fullscreen
            </div>
            <div class="f5 lh-copy mv1 courier">
              unset the window as fullscreen
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_toplevel_unset_fullscreen</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> xdg_toplevel</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Make the surface no longer fullscreen.

After requesting that the surface should be unfullscreened, the
compositor will respond by emitting a configure event.
Whether this actually removes the fullscreen state of the client is
subject to compositor policies.

Making a surface unfullscreen sets states for the surface based on the following:
* the state(s) it may have had before becoming fullscreen
* any state(s) decided by the compositor
* any state(s) requested by the client while the surface was fullscreen

The compositor may include the previous window geometry dimensions in
the configure event, if applicable.

The client must also acknowledge the configure when committing the new
content (see ack_configure).
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_toplevel:set_minimized">
              set_minimized
            </div>
            <div class="f5 lh-copy mv1 courier">
              set the window as minimized
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_toplevel_set_minimized</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_toplevel*</span> xdg_toplevel</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">Request that the compositor minimize your surface. There is no
way to know if the surface is currently minimized, nor is there
any way to unset minimization on this surface.

If you are looking to throttle redrawing when minimized, please
instead use the wl_surface.frame event for this, as this will
also work with live previews on windows in Alt-Tab, Expose or
similar compositor features.
  </div>
          </li>
          
        </ul>
      </li>
      
      <li class="mt2">
        <div class="f2 lh-copy" id="i:xdg_popup">
          xdg_popup
        </div>
        <div class="f6 lh-copy ws-pre-line courier">A popup surface is a short-lived, temporary surface. It can be used to
implement for example menus, popovers, tooltips and other similar user
interface concepts.

A popup can be made to take an explicit grab. See xdg_popup.grab for
details.

When the popup is dismissed, a popup_done event will be sent out, and at
the same time the surface will be unmapped. See the xdg_popup.popup_done
event for details.

Explicitly destroying the xdg_popup object will also dismiss the popup and
unmap the surface. Clients that want to dismiss the popup when another
surface of their own is clicked should dismiss the popup using the destroy
request.

A newly created xdg_popup will be stacked on top of all previously created
xdg_popup surfaces associated with the same xdg_toplevel.

The parent of an xdg_popup must be mapped (see the xdg_surface
description) before the xdg_popup itself.

The x and y arguments passed when creating the popup object specify
where the top left of the popup should be placed, relative to the
local surface coordinates of the parent surface. See
xdg_surface.get_popup. An xdg_popup must intersect with or be at least
partially adjacent to its parent surface.

The client must call wl_surface.commit on the corresponding wl_surface
for the xdg_popup state to take effect.
</div>
        <ul class="list pl0">
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_popup:destroy">
              destroy
            </div>
            <div class="f5 lh-copy mv1 courier">
              remove xdg_popup interface
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_popup_destroy</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_popup*</span> xdg_popup</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">This destroys the popup. Explicitly destroying the xdg_popup
object will also dismiss the popup, and unmap the surface.

If this xdg_popup is not the &quot;topmost&quot; popup, a protocol error
will be sent.
  </div>
          </li>
          
          <li class="mt2">
            <div class="f4 lh-title" id="r:xdg_popup:grab">
              grab
            </div>
            <div class="f5 lh-copy mv1 courier">
              make the popup take an explicit grab
            </div>
            
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">xdg_popup_grab</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct xdg_popup*</span> xdg_popup,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_seat*</span> seat,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> serial</div>
    
  )
</div>
            <div class="f6 lh-copy ws-pre-line courier">This request makes the created popup take an explicit grab. An explicit
grab will be dismissed when the user dismisses the popup, or when the
client destroys the xdg_popup. This can be done by the user clicking
outside the surface, using the keyboard, or even locking the screen
through closing the lid or a timeout.

If the compositor denies the grab, the popup will be immediately
dismissed.

This request must be used in response to some sort of user action like a
button press, key press, or touch down event. The serial number of the
event should be passed as &#x27;serial&#x27;.

The parent of a grabbing popup must either be an xdg_toplevel surface or
another xdg_popup with an explicit grab. If the parent is another
xdg_popup it means that the popups are nested, with this popup now being
the topmost popup.

Nested popups must be destroyed in the reverse order they were created
in, e.g. the only popup you are allowed to destroy at all times is the
topmost one.

When compositors choose to dismiss a popup, they may dismiss every
nested grabbing popup as well. When a compositor dismisses popups, it
will follow the same dismissing order as required from the client.

The parent of a grabbing popup must either be another xdg_popup with an
active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
explicit grabs already taken.

If the topmost grabbing popup is destroyed, the grab will be returned to
the parent of the popup, if that parent previously had an explicit grab.

If the parent is a grabbing popup which has already been dismissed, this
popup will be immediately dismissed. If the parent is a popup that did
not take an explicit grab, an error will be raised.

During a popup grab, the client owning the grab will receive pointer
and touch events for all their surfaces as normal (similar to an
&quot;owner-events&quot; grab in X11 parlance), while the top most grabbing popup
will always have keyboard focus.
  </div>
          </li>
          
        </ul>
      </li>
      
    </ul>

    <h2 class="f4 lh-title">Copyright Info</h2>
    <div class="f7 lh-copy ws-pre-line courier">Copyright  2008-2013 Kristian Hgsberg
Copyright  2013      Rafael Antognolli
Copyright  2013      Jasper St. Pierre
Copyright  2010-2013 Intel Corporation
Copyright  2015-2017 Samsung Electronics Co., Ltd
Copyright  2015-2017 Red Hat Inc.

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the &quot;Software&quot;),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and&#x2f;or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice (including the next
paragraph) shall be included in all copies or substantial portions of the
Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
</div>
  </div>

    </div>

  </body>
</html>