
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>wayland</title>

    <link rel="stylesheet" href="&#x2f;wayland-protocol-docs/main.css">
     
  </head>
  <body class="black-70 flex sans-serif ph4-l">
    <div id="sidebar" class="w-20">
      <div class="fixed vh-100 overflow-y-auto w-20">
        <a href="&#x2f;wayland-protocol-docs/" class="f4 link near-black dim lh-title db mt3">
          Home
        </a>
        
  <div class="ph2">
    

<div>
  <ul class="list pl0">
  
    <li>
      <a href="#i:wl_display" class="link blue underline-hover lh-copy">wl_display</a>

      
        <div>
          <a href="#rh:wl_display" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_display:sync" class="link blue underline-hover lh-copy">sync</a>
          </li>
          
          <li>
            <a href="#r:wl_display:get_registry" class="link blue underline-hover lh-copy">get_registry</a>
          </li>
          
        </ul>
      

      
        <div>
          <a href="#eh:wl_display" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_display:error" class="link blue underline-hover lh-copy">error</a>
          </li>
          
          <li>
            <a href="#e:wl_display:delete_id" class="link blue underline-hover lh-copy">delete_id</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_registry" class="link blue underline-hover lh-copy">wl_registry</a>

      
        <div>
          <a href="#rh:wl_registry" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_registry:bind" class="link blue underline-hover lh-copy">bind</a>
          </li>
          
        </ul>
      

      
        <div>
          <a href="#eh:wl_registry" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_registry:global" class="link blue underline-hover lh-copy">global</a>
          </li>
          
          <li>
            <a href="#e:wl_registry:global_remove" class="link blue underline-hover lh-copy">global_remove</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_callback" class="link blue underline-hover lh-copy">wl_callback</a>

      
      

      
        <div>
          <a href="#eh:wl_callback" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_callback:done" class="link blue underline-hover lh-copy">done</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_compositor" class="link blue underline-hover lh-copy">wl_compositor</a>

      
        <div>
          <a href="#rh:wl_compositor" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_compositor:create_surface" class="link blue underline-hover lh-copy">create_surface</a>
          </li>
          
          <li>
            <a href="#r:wl_compositor:create_region" class="link blue underline-hover lh-copy">create_region</a>
          </li>
          
        </ul>
      

      
      
    </li>
  
    <li>
      <a href="#i:wl_shm_pool" class="link blue underline-hover lh-copy">wl_shm_pool</a>

      
        <div>
          <a href="#rh:wl_shm_pool" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_shm_pool:create_buffer" class="link blue underline-hover lh-copy">create_buffer</a>
          </li>
          
          <li>
            <a href="#r:wl_shm_pool:destroy" class="link blue underline-hover lh-copy">destroy</a>
          </li>
          
          <li>
            <a href="#r:wl_shm_pool:resize" class="link blue underline-hover lh-copy">resize</a>
          </li>
          
        </ul>
      

      
      
    </li>
  
    <li>
      <a href="#i:wl_shm" class="link blue underline-hover lh-copy">wl_shm</a>

      
        <div>
          <a href="#rh:wl_shm" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_shm:create_pool" class="link blue underline-hover lh-copy">create_pool</a>
          </li>
          
        </ul>
      

      
        <div>
          <a href="#eh:wl_shm" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_shm:format" class="link blue underline-hover lh-copy">format</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_buffer" class="link blue underline-hover lh-copy">wl_buffer</a>

      
        <div>
          <a href="#rh:wl_buffer" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_buffer:destroy" class="link blue underline-hover lh-copy">destroy</a>
          </li>
          
        </ul>
      

      
        <div>
          <a href="#eh:wl_buffer" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_buffer:release" class="link blue underline-hover lh-copy">release</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_data_offer" class="link blue underline-hover lh-copy">wl_data_offer</a>

      
        <div>
          <a href="#rh:wl_data_offer" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_data_offer:accept" class="link blue underline-hover lh-copy">accept</a>
          </li>
          
          <li>
            <a href="#r:wl_data_offer:receive" class="link blue underline-hover lh-copy">receive</a>
          </li>
          
          <li>
            <a href="#r:wl_data_offer:destroy" class="link blue underline-hover lh-copy">destroy</a>
          </li>
          
          <li>
            <a href="#r:wl_data_offer:finish" class="link blue underline-hover lh-copy">finish</a>
          </li>
          
          <li>
            <a href="#r:wl_data_offer:set_actions" class="link blue underline-hover lh-copy">set_actions</a>
          </li>
          
        </ul>
      

      
        <div>
          <a href="#eh:wl_data_offer" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_data_offer:offer" class="link blue underline-hover lh-copy">offer</a>
          </li>
          
          <li>
            <a href="#e:wl_data_offer:source_actions" class="link blue underline-hover lh-copy">source_actions</a>
          </li>
          
          <li>
            <a href="#e:wl_data_offer:action" class="link blue underline-hover lh-copy">action</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_data_source" class="link blue underline-hover lh-copy">wl_data_source</a>

      
        <div>
          <a href="#rh:wl_data_source" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_data_source:offer" class="link blue underline-hover lh-copy">offer</a>
          </li>
          
          <li>
            <a href="#r:wl_data_source:destroy" class="link blue underline-hover lh-copy">destroy</a>
          </li>
          
          <li>
            <a href="#r:wl_data_source:set_actions" class="link blue underline-hover lh-copy">set_actions</a>
          </li>
          
        </ul>
      

      
        <div>
          <a href="#eh:wl_data_source" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_data_source:target" class="link blue underline-hover lh-copy">target</a>
          </li>
          
          <li>
            <a href="#e:wl_data_source:send" class="link blue underline-hover lh-copy">send</a>
          </li>
          
          <li>
            <a href="#e:wl_data_source:cancelled" class="link blue underline-hover lh-copy">cancelled</a>
          </li>
          
          <li>
            <a href="#e:wl_data_source:dnd_drop_performed" class="link blue underline-hover lh-copy">dnd_drop_performed</a>
          </li>
          
          <li>
            <a href="#e:wl_data_source:dnd_finished" class="link blue underline-hover lh-copy">dnd_finished</a>
          </li>
          
          <li>
            <a href="#e:wl_data_source:action" class="link blue underline-hover lh-copy">action</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_data_device" class="link blue underline-hover lh-copy">wl_data_device</a>

      
        <div>
          <a href="#rh:wl_data_device" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_data_device:start_drag" class="link blue underline-hover lh-copy">start_drag</a>
          </li>
          
          <li>
            <a href="#r:wl_data_device:set_selection" class="link blue underline-hover lh-copy">set_selection</a>
          </li>
          
          <li>
            <a href="#r:wl_data_device:release" class="link blue underline-hover lh-copy">release</a>
          </li>
          
        </ul>
      

      
        <div>
          <a href="#eh:wl_data_device" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_data_device:data_offer" class="link blue underline-hover lh-copy">data_offer</a>
          </li>
          
          <li>
            <a href="#e:wl_data_device:enter" class="link blue underline-hover lh-copy">enter</a>
          </li>
          
          <li>
            <a href="#e:wl_data_device:leave" class="link blue underline-hover lh-copy">leave</a>
          </li>
          
          <li>
            <a href="#e:wl_data_device:motion" class="link blue underline-hover lh-copy">motion</a>
          </li>
          
          <li>
            <a href="#e:wl_data_device:drop" class="link blue underline-hover lh-copy">drop</a>
          </li>
          
          <li>
            <a href="#e:wl_data_device:selection" class="link blue underline-hover lh-copy">selection</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_data_device_manager" class="link blue underline-hover lh-copy">wl_data_device_manager</a>

      
        <div>
          <a href="#rh:wl_data_device_manager" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_data_device_manager:create_data_source" class="link blue underline-hover lh-copy">create_data_source</a>
          </li>
          
          <li>
            <a href="#r:wl_data_device_manager:get_data_device" class="link blue underline-hover lh-copy">get_data_device</a>
          </li>
          
        </ul>
      

      
      
    </li>
  
    <li>
      <a href="#i:wl_shell" class="link blue underline-hover lh-copy">wl_shell</a>

      
        <div>
          <a href="#rh:wl_shell" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_shell:get_shell_surface" class="link blue underline-hover lh-copy">get_shell_surface</a>
          </li>
          
        </ul>
      

      
      
    </li>
  
    <li>
      <a href="#i:wl_shell_surface" class="link blue underline-hover lh-copy">wl_shell_surface</a>

      
        <div>
          <a href="#rh:wl_shell_surface" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_shell_surface:pong" class="link blue underline-hover lh-copy">pong</a>
          </li>
          
          <li>
            <a href="#r:wl_shell_surface:move" class="link blue underline-hover lh-copy">move</a>
          </li>
          
          <li>
            <a href="#r:wl_shell_surface:resize" class="link blue underline-hover lh-copy">resize</a>
          </li>
          
          <li>
            <a href="#r:wl_shell_surface:set_toplevel" class="link blue underline-hover lh-copy">set_toplevel</a>
          </li>
          
          <li>
            <a href="#r:wl_shell_surface:set_transient" class="link blue underline-hover lh-copy">set_transient</a>
          </li>
          
          <li>
            <a href="#r:wl_shell_surface:set_fullscreen" class="link blue underline-hover lh-copy">set_fullscreen</a>
          </li>
          
          <li>
            <a href="#r:wl_shell_surface:set_popup" class="link blue underline-hover lh-copy">set_popup</a>
          </li>
          
          <li>
            <a href="#r:wl_shell_surface:set_maximized" class="link blue underline-hover lh-copy">set_maximized</a>
          </li>
          
          <li>
            <a href="#r:wl_shell_surface:set_title" class="link blue underline-hover lh-copy">set_title</a>
          </li>
          
          <li>
            <a href="#r:wl_shell_surface:set_class" class="link blue underline-hover lh-copy">set_class</a>
          </li>
          
        </ul>
      

      
        <div>
          <a href="#eh:wl_shell_surface" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_shell_surface:ping" class="link blue underline-hover lh-copy">ping</a>
          </li>
          
          <li>
            <a href="#e:wl_shell_surface:configure" class="link blue underline-hover lh-copy">configure</a>
          </li>
          
          <li>
            <a href="#e:wl_shell_surface:popup_done" class="link blue underline-hover lh-copy">popup_done</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_surface" class="link blue underline-hover lh-copy">wl_surface</a>

      
        <div>
          <a href="#rh:wl_surface" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_surface:destroy" class="link blue underline-hover lh-copy">destroy</a>
          </li>
          
          <li>
            <a href="#r:wl_surface:attach" class="link blue underline-hover lh-copy">attach</a>
          </li>
          
          <li>
            <a href="#r:wl_surface:damage" class="link blue underline-hover lh-copy">damage</a>
          </li>
          
          <li>
            <a href="#r:wl_surface:frame" class="link blue underline-hover lh-copy">frame</a>
          </li>
          
          <li>
            <a href="#r:wl_surface:set_opaque_region" class="link blue underline-hover lh-copy">set_opaque_region</a>
          </li>
          
          <li>
            <a href="#r:wl_surface:set_input_region" class="link blue underline-hover lh-copy">set_input_region</a>
          </li>
          
          <li>
            <a href="#r:wl_surface:commit" class="link blue underline-hover lh-copy">commit</a>
          </li>
          
          <li>
            <a href="#r:wl_surface:set_buffer_transform" class="link blue underline-hover lh-copy">set_buffer_transform</a>
          </li>
          
          <li>
            <a href="#r:wl_surface:set_buffer_scale" class="link blue underline-hover lh-copy">set_buffer_scale</a>
          </li>
          
          <li>
            <a href="#r:wl_surface:damage_buffer" class="link blue underline-hover lh-copy">damage_buffer</a>
          </li>
          
        </ul>
      

      
        <div>
          <a href="#eh:wl_surface" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_surface:enter" class="link blue underline-hover lh-copy">enter</a>
          </li>
          
          <li>
            <a href="#e:wl_surface:leave" class="link blue underline-hover lh-copy">leave</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_seat" class="link blue underline-hover lh-copy">wl_seat</a>

      
        <div>
          <a href="#rh:wl_seat" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_seat:get_pointer" class="link blue underline-hover lh-copy">get_pointer</a>
          </li>
          
          <li>
            <a href="#r:wl_seat:get_keyboard" class="link blue underline-hover lh-copy">get_keyboard</a>
          </li>
          
          <li>
            <a href="#r:wl_seat:get_touch" class="link blue underline-hover lh-copy">get_touch</a>
          </li>
          
          <li>
            <a href="#r:wl_seat:release" class="link blue underline-hover lh-copy">release</a>
          </li>
          
        </ul>
      

      
        <div>
          <a href="#eh:wl_seat" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_seat:capabilities" class="link blue underline-hover lh-copy">capabilities</a>
          </li>
          
          <li>
            <a href="#e:wl_seat:name" class="link blue underline-hover lh-copy">name</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_pointer" class="link blue underline-hover lh-copy">wl_pointer</a>

      
        <div>
          <a href="#rh:wl_pointer" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_pointer:set_cursor" class="link blue underline-hover lh-copy">set_cursor</a>
          </li>
          
          <li>
            <a href="#r:wl_pointer:release" class="link blue underline-hover lh-copy">release</a>
          </li>
          
        </ul>
      

      
        <div>
          <a href="#eh:wl_pointer" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_pointer:enter" class="link blue underline-hover lh-copy">enter</a>
          </li>
          
          <li>
            <a href="#e:wl_pointer:leave" class="link blue underline-hover lh-copy">leave</a>
          </li>
          
          <li>
            <a href="#e:wl_pointer:motion" class="link blue underline-hover lh-copy">motion</a>
          </li>
          
          <li>
            <a href="#e:wl_pointer:button" class="link blue underline-hover lh-copy">button</a>
          </li>
          
          <li>
            <a href="#e:wl_pointer:axis" class="link blue underline-hover lh-copy">axis</a>
          </li>
          
          <li>
            <a href="#e:wl_pointer:frame" class="link blue underline-hover lh-copy">frame</a>
          </li>
          
          <li>
            <a href="#e:wl_pointer:axis_source" class="link blue underline-hover lh-copy">axis_source</a>
          </li>
          
          <li>
            <a href="#e:wl_pointer:axis_stop" class="link blue underline-hover lh-copy">axis_stop</a>
          </li>
          
          <li>
            <a href="#e:wl_pointer:axis_discrete" class="link blue underline-hover lh-copy">axis_discrete</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_keyboard" class="link blue underline-hover lh-copy">wl_keyboard</a>

      
        <div>
          <a href="#rh:wl_keyboard" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_keyboard:release" class="link blue underline-hover lh-copy">release</a>
          </li>
          
        </ul>
      

      
        <div>
          <a href="#eh:wl_keyboard" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_keyboard:keymap" class="link blue underline-hover lh-copy">keymap</a>
          </li>
          
          <li>
            <a href="#e:wl_keyboard:enter" class="link blue underline-hover lh-copy">enter</a>
          </li>
          
          <li>
            <a href="#e:wl_keyboard:leave" class="link blue underline-hover lh-copy">leave</a>
          </li>
          
          <li>
            <a href="#e:wl_keyboard:key" class="link blue underline-hover lh-copy">key</a>
          </li>
          
          <li>
            <a href="#e:wl_keyboard:modifiers" class="link blue underline-hover lh-copy">modifiers</a>
          </li>
          
          <li>
            <a href="#e:wl_keyboard:repeat_info" class="link blue underline-hover lh-copy">repeat_info</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_touch" class="link blue underline-hover lh-copy">wl_touch</a>

      
        <div>
          <a href="#rh:wl_touch" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_touch:release" class="link blue underline-hover lh-copy">release</a>
          </li>
          
        </ul>
      

      
        <div>
          <a href="#eh:wl_touch" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_touch:down" class="link blue underline-hover lh-copy">down</a>
          </li>
          
          <li>
            <a href="#e:wl_touch:up" class="link blue underline-hover lh-copy">up</a>
          </li>
          
          <li>
            <a href="#e:wl_touch:motion" class="link blue underline-hover lh-copy">motion</a>
          </li>
          
          <li>
            <a href="#e:wl_touch:frame" class="link blue underline-hover lh-copy">frame</a>
          </li>
          
          <li>
            <a href="#e:wl_touch:cancel" class="link blue underline-hover lh-copy">cancel</a>
          </li>
          
          <li>
            <a href="#e:wl_touch:shape" class="link blue underline-hover lh-copy">shape</a>
          </li>
          
          <li>
            <a href="#e:wl_touch:orientation" class="link blue underline-hover lh-copy">orientation</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_output" class="link blue underline-hover lh-copy">wl_output</a>

      
        <div>
          <a href="#rh:wl_output" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_output:release" class="link blue underline-hover lh-copy">release</a>
          </li>
          
        </ul>
      

      
        <div>
          <a href="#eh:wl_output" class="link blue underline-hover lh-copy pl3">Events</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#e:wl_output:geometry" class="link blue underline-hover lh-copy">geometry</a>
          </li>
          
          <li>
            <a href="#e:wl_output:mode" class="link blue underline-hover lh-copy">mode</a>
          </li>
          
          <li>
            <a href="#e:wl_output:done" class="link blue underline-hover lh-copy">done</a>
          </li>
          
          <li>
            <a href="#e:wl_output:scale" class="link blue underline-hover lh-copy">scale</a>
          </li>
          
        </ul>
      
    </li>
  
    <li>
      <a href="#i:wl_region" class="link blue underline-hover lh-copy">wl_region</a>

      
        <div>
          <a href="#rh:wl_region" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_region:destroy" class="link blue underline-hover lh-copy">destroy</a>
          </li>
          
          <li>
            <a href="#r:wl_region:add" class="link blue underline-hover lh-copy">add</a>
          </li>
          
          <li>
            <a href="#r:wl_region:subtract" class="link blue underline-hover lh-copy">subtract</a>
          </li>
          
        </ul>
      

      
      
    </li>
  
    <li>
      <a href="#i:wl_subcompositor" class="link blue underline-hover lh-copy">wl_subcompositor</a>

      
        <div>
          <a href="#rh:wl_subcompositor" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_subcompositor:destroy" class="link blue underline-hover lh-copy">destroy</a>
          </li>
          
          <li>
            <a href="#r:wl_subcompositor:get_subsurface" class="link blue underline-hover lh-copy">get_subsurface</a>
          </li>
          
        </ul>
      

      
      
    </li>
  
    <li>
      <a href="#i:wl_subsurface" class="link blue underline-hover lh-copy">wl_subsurface</a>

      
        <div>
          <a href="#rh:wl_subsurface" class="link blue underline-hover lh-copy pl3">Requests</a>
        </div>
        <ul class="list pl4">
          
          <li>
            <a href="#r:wl_subsurface:destroy" class="link blue underline-hover lh-copy">destroy</a>
          </li>
          
          <li>
            <a href="#r:wl_subsurface:set_position" class="link blue underline-hover lh-copy">set_position</a>
          </li>
          
          <li>
            <a href="#r:wl_subsurface:place_above" class="link blue underline-hover lh-copy">place_above</a>
          </li>
          
          <li>
            <a href="#r:wl_subsurface:place_below" class="link blue underline-hover lh-copy">place_below</a>
          </li>
          
          <li>
            <a href="#r:wl_subsurface:set_sync" class="link blue underline-hover lh-copy">set_sync</a>
          </li>
          
          <li>
            <a href="#r:wl_subsurface:set_desync" class="link blue underline-hover lh-copy">set_desync</a>
          </li>
          
        </ul>
      

      
      
    </li>
  
  </ul>
</div>
  </div>

      </div>
    </div>

    <main id="content" class="mh4">
      
  <div class="ph2">
    <h1 class="f1 lh-title">wayland</h1>
    <ul class="list pl0">
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_display">
          <a href="#i:wl_display" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_display
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">The core global object.  This is a special singleton object.  It
is used for internal Wayland protocol features.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_display">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_display:sync">
                <a href="#r:wl_display:sync" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  sync
                </div>
                <div class="f5 ml2">
                  asynchronous roundtrip
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>struct wl_callback* </span><span class="dark-blue">wl_display_sync</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_display*</span> wl_display</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">The sync request asks the server to emit the &#x27;done&#x27; event
on the returned wl_callback object.  Since requests are
handled in-order and events are delivered in-order, this can
be used as a barrier to ensure all previous requests and the
resulting events have been handled.

The object returned by this request will be destroyed by the
compositor after the callback is fired and as such the client must not
attempt to use it after that point.

The callback_data passed in the callback is the event serial.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_display:get_registry">
                <a href="#r:wl_display:get_registry" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  get_registry
                </div>
                <div class="f5 ml2">
                  get global registry object
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>struct wl_registry* </span><span class="dark-blue">wl_display_get_registry</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_display*</span> wl_display</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">This request creates a registry object that allows the client
to list and bind the global objects available from the
compositor.

It should be noted that the server side resources consumed in
response to a get_registry request can only be released when the
client disconnects, not when the client side proxy is destroyed.
Therefore, clients should invoke get_registry as infrequently as
possible to avoid wasting memory.
  </div>
            </li>
            
          </ul>
        

        
          <h3 class=" f5 lh-title" id="eh:wl_display">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_display:error">
                <a href="#e:wl_display:error" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  error
                </div>
                <div class="f5 ml2">
                  fatal error event
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">struct void*</span> object_id <span class="green">/* object where the error occurred */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> code <span class="green">/* error code */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">const char*</span> message <span class="green">/* error description */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">The error event is sent out when a fatal (non-recoverable)
error has occurred.  The object_id argument is the object
where the error occurred, most often in response to a request
to that object.  The code identifies the error and is defined
by the object interface.  As such, each interface defines its
own set of error codes.  The message is a brief description
of the error, for (debugging) convenience.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_display:delete_id">
                <a href="#e:wl_display:delete_id" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  delete_id
                </div>
                <div class="f5 ml2">
                  acknowledge object ID deletion
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> id <span class="green">/* deleted object ID */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">This event is used internally by the object ID management
logic. When a client deletes an object that it had created,
the server will send this event to acknowledge that it has
seen the delete request. When the client receives this event,
it will know that it can safely reuse the object ID.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_registry">
          <a href="#i:wl_registry" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_registry
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">The singleton global registry object.  The server has a number of
global objects that are available to all clients.  These objects
typically represent an actual object in the server (for example,
an input device) or they are singleton objects that provide
extension functionality.

When a client creates a registry object, the registry object
will emit a global event for each global currently in the
registry.  Globals come and go as a result of device or
monitor hotplugs, reconfiguration or other events, and the
registry will send out global and global_remove events to
keep the client up to date with the changes.  To mark the end
of the initial burst of events, the client can use the
wl_display.sync request immediately after calling
wl_display.get_registry.

A client can bind to a global object by using the bind
request.  This creates a client-side handle that lets the object
emit events to the client and lets the client invoke requests on
the object.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_registry">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_registry:bind">
                <a href="#r:wl_registry:bind" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  bind
                </div>
                <div class="f5 ml2">
                  bind an object to the display
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void* </span><span class="dark-blue">wl_registry_bind</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_registry*</span> wl_registry,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> name <span class="green">/* unique numeric name of the object */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Binds a new, client-created object to the server using the
specified name as the identifier.
  </div>
            </li>
            
          </ul>
        

        
          <h3 class=" f5 lh-title" id="eh:wl_registry">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_registry:global">
                <a href="#e:wl_registry:global" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  global
                </div>
                <div class="f5 ml2">
                  announce global object
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> name <span class="green">/* numeric name of the global object */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">const char*</span> interface <span class="green">/* interface implemented by the object */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> version <span class="green">/* interface version */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Notify the client of global objects.

The event notifies the client that a global object with
the given name is now available, and it implements the
given version of the given interface.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_registry:global_remove">
                <a href="#e:wl_registry:global_remove" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  global_remove
                </div>
                <div class="f5 ml2">
                  announce removal of global object
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> name <span class="green">/* numeric name of the global object */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Notify the client of removed global objects.

This event notifies the client that the global identified
by name is no longer available.  If the client bound to
the global using the bind request, the client should now
destroy that object.

The object remains valid and requests to the object will be
ignored until the client destroys it, to avoid races between
the global going away and a client sending a request to it.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_callback">
          <a href="#i:wl_callback" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_callback
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">Clients can handle the &#x27;done&#x27; event to get notified when
the related request is done.
</div>

        
        

        
          <h3 class=" f5 lh-title" id="eh:wl_callback">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_callback:done">
                <a href="#e:wl_callback:done" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  done
                </div>
                <div class="f5 ml2">
                  done event
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> callback_data <span class="green">/* request-specific data for the callback */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Notify the client when the related request is done.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_compositor">
          <a href="#i:wl_compositor" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_compositor
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">A compositor.  This object is a singleton global.  The
compositor is in charge of combining the contents of multiple
surfaces into one displayable output.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_compositor">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_compositor:create_surface">
                <a href="#r:wl_compositor:create_surface" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  create_surface
                </div>
                <div class="f5 ml2">
                  create new surface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>struct wl_surface* </span><span class="dark-blue">wl_compositor_create_surface</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_compositor*</span> wl_compositor</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Ask the compositor to create a new surface.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_compositor:create_region">
                <a href="#r:wl_compositor:create_region" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  create_region
                </div>
                <div class="f5 ml2">
                  create new region
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>struct wl_region* </span><span class="dark-blue">wl_compositor_create_region</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_compositor*</span> wl_compositor</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Ask the compositor to create a new region.
  </div>
            </li>
            
          </ul>
        

        

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_shm_pool">
          <a href="#i:wl_shm_pool" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_shm_pool
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">The wl_shm_pool object encapsulates a piece of memory shared
between the compositor and client.  Through the wl_shm_pool
object, the client can allocate shared memory wl_buffer objects.
All objects created through the same pool share the same
underlying mapped memory. Reusing the mapped memory avoids the
setup&#x2f;teardown overhead and is useful when interactively resizing
a surface or for many small buffers.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_shm_pool">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shm_pool:create_buffer">
                <a href="#r:wl_shm_pool:create_buffer" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  create_buffer
                </div>
                <div class="f5 ml2">
                  create a buffer from the pool
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>struct wl_buffer* </span><span class="dark-blue">wl_shm_pool_create_buffer</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shm_pool*</span> wl_shm_pool,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> offset, <span class="green">/* buffer byte offset within the pool */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> width, <span class="green">/* buffer width, in pixels */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> height, <span class="green">/* buffer height, in pixels */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> stride, <span class="green">/* number of bytes from the beginning of one row to the beginning of the next row */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> format <span class="green">/* buffer pixel format */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Create a wl_buffer object from the pool.

The buffer is created offset bytes into the pool and has
width and height as specified.  The stride argument specifies
the number of bytes from the beginning of one row to the beginning
of the next.  The format is the pixel format of the buffer and
must be one of those advertised through the wl_shm.format event.

A buffer will keep a reference to the pool it was created from
so it is valid to destroy the pool immediately after creating
a buffer from it.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shm_pool:destroy">
                <a href="#r:wl_shm_pool:destroy" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  destroy
                </div>
                <div class="f5 ml2">
                  destroy the pool
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_shm_pool_destroy</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shm_pool*</span> wl_shm_pool</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Destroy the shared memory pool.

The mmapped memory will be released when all
buffers that have been created from this pool
are gone.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shm_pool:resize">
                <a href="#r:wl_shm_pool:resize" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  resize
                </div>
                <div class="f5 ml2">
                  change the size of the pool mapping
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_shm_pool_resize</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shm_pool*</span> wl_shm_pool,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> size <span class="green">/* new size of the pool, in bytes */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">This request will cause the server to remap the backing memory
for the pool from the file descriptor passed when the pool was
created, but using the new size.  This request can only be
used to make the pool bigger.
  </div>
            </li>
            
          </ul>
        

        

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_shm">
          <a href="#i:wl_shm" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_shm
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">A singleton global object that provides support for shared
memory.

Clients can create wl_shm_pool objects using the create_pool
request.

At connection setup time, the wl_shm object emits one or more
format events to inform clients about the valid pixel formats
that can be used for buffers.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_shm">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shm:create_pool">
                <a href="#r:wl_shm:create_pool" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  create_pool
                </div>
                <div class="f5 ml2">
                  create a shm pool
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>struct wl_shm_pool* </span><span class="dark-blue">wl_shm_create_pool</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shm*</span> wl_shm,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> fd, <span class="green">/* file descriptor for the pool */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> size <span class="green">/* pool size, in bytes */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Create a new wl_shm_pool object.

The pool can be used to create shared memory based buffer
objects.  The server will mmap size bytes of the passed file
descriptor, to use as backing memory for the pool.
  </div>
            </li>
            
          </ul>
        

        
          <h3 class=" f5 lh-title" id="eh:wl_shm">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_shm:format">
                <a href="#e:wl_shm:format" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  format
                </div>
                <div class="f5 ml2">
                  pixel format description
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> format <span class="green">/* buffer pixel format */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Informs the client about a valid pixel format that
can be used for buffers. Known formats include
argb8888 and xrgb8888.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_buffer">
          <a href="#i:wl_buffer" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_buffer
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">A buffer provides the content for a wl_surface. Buffers are
created through factory interfaces such as wl_drm, wl_shm or
similar. It has a width and a height and can be attached to a
wl_surface, but the mechanism by which a client provides and
updates the contents is defined by the buffer factory interface.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_buffer">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_buffer:destroy">
                <a href="#r:wl_buffer:destroy" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  destroy
                </div>
                <div class="f5 ml2">
                  destroy a buffer
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_buffer_destroy</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_buffer*</span> wl_buffer</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Destroy a buffer. If and how you need to release the backing
storage is defined by the buffer factory interface.

For possible side-effects to a surface, see wl_surface.attach.
  </div>
            </li>
            
          </ul>
        

        
          <h3 class=" f5 lh-title" id="eh:wl_buffer">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_buffer:release">
                <a href="#e:wl_buffer:release" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  release
                </div>
                <div class="f5 ml2">
                  compositor releases buffer
                </div>
              </div>

              

              <div class="f6 lh-copy ws-pre-line courier mt2">Sent when this wl_buffer is no longer used by the compositor.
The client is now free to reuse or destroy this buffer and its
backing storage.

If a client receives a release event before the frame callback
requested in the same wl_surface.commit that attaches this
wl_buffer to a surface, then the client is immediately free to
reuse the buffer and its backing storage, and does not need a
second buffer for the next surface content update. Typically
this is possible, when the compositor maintains a copy of the
wl_surface contents, e.g. as a GL texture. This is an important
optimization for GL(ES) compositors with wl_shm clients.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_data_offer">
          <a href="#i:wl_data_offer" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_data_offer
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">A wl_data_offer represents a piece of data offered for transfer
by another client (the source client).  It is used by the
copy-and-paste and drag-and-drop mechanisms.  The offer
describes the different mime types that the data can be
converted to and provides the mechanism for transferring the
data directly from the source client.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_data_offer">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_data_offer:accept">
                <a href="#r:wl_data_offer:accept" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  accept
                </div>
                <div class="f5 ml2">
                  accept one of the offered mime types
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_data_offer_accept</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_offer*</span> wl_data_offer,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> serial, <span class="green">/* serial number of the accept request */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">const char*</span> mime_type <span class="green">/* mime type accepted by the client */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Indicate that the client can accept the given mime type, or
NULL for not accepted.

For objects of version 2 or older, this request is used by the
client to give feedback whether the client can receive the given
mime type, or NULL if none is accepted; the feedback does not
determine whether the drag-and-drop operation succeeds or not.

For objects of version 3 or newer, this request determines the
final result of the drag-and-drop operation. If the end result
is that no mime types were accepted, the drag-and-drop operation
will be cancelled and the corresponding drag source will receive
wl_data_source.cancelled. Clients may still use this event in
conjunction with wl_data_source.action for feedback.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_data_offer:receive">
                <a href="#r:wl_data_offer:receive" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  receive
                </div>
                <div class="f5 ml2">
                  request that the data is transferred
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_data_offer_receive</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_offer*</span> wl_data_offer,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">const char*</span> mime_type, <span class="green">/* mime type desired by receiver */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> fd <span class="green">/* file descriptor for data transfer */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">To transfer the offered data, the client issues this request
and indicates the mime type it wants to receive.  The transfer
happens through the passed file descriptor (typically created
with the pipe system call).  The source client writes the data
in the mime type representation requested and then closes the
file descriptor.

The receiving client reads from the read end of the pipe until
EOF and then closes its end, at which point the transfer is
complete.

This request may happen multiple times for different mime types,
both before and after wl_data_device.drop. Drag-and-drop destination
clients may preemptively fetch data or examine it more closely to
determine acceptance.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_data_offer:destroy">
                <a href="#r:wl_data_offer:destroy" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  destroy
                </div>
                <div class="f5 ml2">
                  destroy data offer
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_data_offer_destroy</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_offer*</span> wl_data_offer</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Destroy the data offer.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_data_offer:finish">
                <a href="#r:wl_data_offer:finish" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  finish
                </div>
                <div class="f5 ml2">
                  the offer will no longer be used
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_data_offer_finish</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_offer*</span> wl_data_offer</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Notifies the compositor that the drag destination successfully
finished the drag-and-drop operation.

Upon receiving this request, the compositor will emit
wl_data_source.dnd_finished on the drag source client.

It is a client error to perform other requests than
wl_data_offer.destroy after this one. It is also an error to perform
this request after a NULL mime type has been set in
wl_data_offer.accept or no action was received through
wl_data_offer.action.

If wl_data_offer.finish request is received for a non drag and drop
operation, the invalid_finish protocol error is raised.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_data_offer:set_actions">
                <a href="#r:wl_data_offer:set_actions" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_actions
                </div>
                <div class="f5 ml2">
                  set the available&#x2f;preferred drag-and-drop actions
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_data_offer_set_actions</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_offer*</span> wl_data_offer,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> dnd_actions, <span class="green">/* actions supported by the destination client */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> preferred_action <span class="green">/* action preferred by the destination client */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Sets the actions that the destination side client supports for
this operation. This request may trigger the emission of
wl_data_source.action and wl_data_offer.action events if the compositor
needs to change the selected action.

This request can be called multiple times throughout the
drag-and-drop operation, typically in response to wl_data_device.enter
or wl_data_device.motion events.

This request determines the final result of the drag-and-drop
operation. If the end result is that no action is accepted,
the drag source will receive wl_data_source.cancelled.

The dnd_actions argument must contain only values expressed in the
wl_data_device_manager.dnd_actions enum, and the preferred_action
argument must only contain one of those values set, otherwise it
will result in a protocol error.

While managing an &quot;ask&quot; action, the destination drag-and-drop client
may perform further wl_data_offer.receive requests, and is expected
to perform one last wl_data_offer.set_actions request with a preferred
action other than &quot;ask&quot; (and optionally wl_data_offer.accept) before
requesting wl_data_offer.finish, in order to convey the action selected
by the user. If the preferred action is not in the
wl_data_offer.source_actions mask, an error will be raised.

If the &quot;ask&quot; action is dismissed (e.g. user cancellation), the client
is expected to perform wl_data_offer.destroy right away.

This request can only be made on drag-and-drop offers, a protocol error
will be raised otherwise.
  </div>
            </li>
            
          </ul>
        

        
          <h3 class=" f5 lh-title" id="eh:wl_data_offer">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_offer:offer">
                <a href="#e:wl_data_offer:offer" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  offer
                </div>
                <div class="f5 ml2">
                  advertise offered mime type
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">const char*</span> mime_type <span class="green">/* offered mime type */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Sent immediately after creating the wl_data_offer object.  One
event per offered mime type.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_offer:source_actions">
                <a href="#e:wl_data_offer:source_actions" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  source_actions
                </div>
                <div class="f5 ml2">
                  notify the source-side available actions
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> source_actions <span class="green">/* actions offered by the data source */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">This event indicates the actions offered by the data source. It
will be sent right after wl_data_device.enter, or anytime the source
side changes its offered actions through wl_data_source.set_actions.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_offer:action">
                <a href="#e:wl_data_offer:action" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  action
                </div>
                <div class="f5 ml2">
                  notify the selected action
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> dnd_action <span class="green">/* action selected by the compositor */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">This event indicates the action selected by the compositor after
matching the source&#x2f;destination side actions. Only one action (or
none) will be offered here.

This event can be emitted multiple times during the drag-and-drop
operation in response to destination side action changes through
wl_data_offer.set_actions.

This event will no longer be emitted after wl_data_device.drop
happened on the drag-and-drop destination, the client must
honor the last action received, or the last preferred one set
through wl_data_offer.set_actions when handling an &quot;ask&quot; action.

Compositors may also change the selected action on the fly, mainly
in response to keyboard modifier changes during the drag-and-drop
operation.

The most recent action received is always the valid one. Prior to
receiving wl_data_device.drop, the chosen action may change (e.g.
due to keyboard modifiers being pressed). At the time of receiving
wl_data_device.drop the drag-and-drop destination must honor the
last action received.

Action changes may still happen after wl_data_device.drop,
especially on &quot;ask&quot; actions, where the drag-and-drop destination
may choose another action afterwards. Action changes happening
at this stage are always the result of inter-client negotiation, the
compositor shall no longer be able to induce a different action.

Upon &quot;ask&quot; actions, it is expected that the drag-and-drop destination
may potentially choose a different action and&#x2f;or mime type,
based on wl_data_offer.source_actions and finally chosen by the
user (e.g. popping up a menu with the available options). The
final wl_data_offer.set_actions and wl_data_offer.accept requests
must happen before the call to wl_data_offer.finish.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_data_source">
          <a href="#i:wl_data_source" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_data_source
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">The wl_data_source object is the source side of a wl_data_offer.
It is created by the source client in a data transfer and
provides a way to describe the offered data and a way to respond
to requests to transfer the data.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_data_source">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_data_source:offer">
                <a href="#r:wl_data_source:offer" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  offer
                </div>
                <div class="f5 ml2">
                  add an offered mime type
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_data_source_offer</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_source*</span> wl_data_source,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">const char*</span> mime_type <span class="green">/* mime type offered by the data source */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">This request adds a mime type to the set of mime types
advertised to targets.  Can be called several times to offer
multiple types.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_data_source:destroy">
                <a href="#r:wl_data_source:destroy" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  destroy
                </div>
                <div class="f5 ml2">
                  destroy the data source
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_data_source_destroy</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_source*</span> wl_data_source</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Destroy the data source.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_data_source:set_actions">
                <a href="#r:wl_data_source:set_actions" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_actions
                </div>
                <div class="f5 ml2">
                  set the available drag-and-drop actions
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_data_source_set_actions</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_source*</span> wl_data_source,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> dnd_actions <span class="green">/* actions supported by the data source */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Sets the actions that the source side client supports for this
operation. This request may trigger wl_data_source.action and
wl_data_offer.action events if the compositor needs to change the
selected action.

The dnd_actions argument must contain only values expressed in the
wl_data_device_manager.dnd_actions enum, otherwise it will result
in a protocol error.

This request must be made once only, and can only be made on sources
used in drag-and-drop, so it must be performed before
wl_data_device.start_drag. Attempting to use the source other than
for drag-and-drop will raise a protocol error.
  </div>
            </li>
            
          </ul>
        

        
          <h3 class=" f5 lh-title" id="eh:wl_data_source">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_source:target">
                <a href="#e:wl_data_source:target" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  target
                </div>
                <div class="f5 ml2">
                  a target accepts an offered mime type
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">const char*</span> mime_type <span class="green">/* mime type accepted by the target */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Sent when a target accepts pointer_focus or motion events.  If
a target does not accept any of the offered types, type is NULL.

Used for feedback during drag-and-drop.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_source:send">
                <a href="#e:wl_data_source:send" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  send
                </div>
                <div class="f5 ml2">
                  send the data
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">const char*</span> mime_type <span class="green">/* mime type for the data */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> fd <span class="green">/* file descriptor for the data */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Request for data from the client.  Send the data as the
specified mime type over the passed file descriptor, then
close it.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_source:cancelled">
                <a href="#e:wl_data_source:cancelled" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  cancelled
                </div>
                <div class="f5 ml2">
                  selection was cancelled
                </div>
              </div>

              

              <div class="f6 lh-copy ws-pre-line courier mt2">This data source is no longer valid. There are several reasons why
this could happen:

- The data source has been replaced by another data source.
- The drag-and-drop operation was performed, but the drop destination
  did not accept any of the mime types offered through
  wl_data_source.target.
- The drag-and-drop operation was performed, but the drop destination
  did not select any of the actions present in the mask offered through
  wl_data_source.action.
- The drag-and-drop operation was performed but didn&#x27;t happen over a
  surface.
- The compositor cancelled the drag-and-drop operation (e.g. compositor
  dependent timeouts to avoid stale drag-and-drop transfers).

The client should clean up and destroy this data source.

For objects of version 2 or older, wl_data_source.cancelled will
only be emitted if the data source was replaced by another data
source.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_source:dnd_drop_performed">
                <a href="#e:wl_data_source:dnd_drop_performed" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  dnd_drop_performed
                </div>
                <div class="f5 ml2">
                  the drag-and-drop operation physically finished
                </div>
              </div>

              

              <div class="f6 lh-copy ws-pre-line courier mt2">The user performed the drop action. This event does not indicate
acceptance, wl_data_source.cancelled may still be emitted afterwards
if the drop destination does not accept any mime type.

However, this event might however not be received if the compositor
cancelled the drag-and-drop operation before this event could happen.

Note that the data_source may still be used in the future and should
not be destroyed here.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_source:dnd_finished">
                <a href="#e:wl_data_source:dnd_finished" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  dnd_finished
                </div>
                <div class="f5 ml2">
                  the drag-and-drop operation concluded
                </div>
              </div>

              

              <div class="f6 lh-copy ws-pre-line courier mt2">The drop destination finished interoperating with this data
source, so the client is now free to destroy this data source and
free all associated data.

If the action used to perform the operation was &quot;move&quot;, the
source can now delete the transferred data.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_source:action">
                <a href="#e:wl_data_source:action" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  action
                </div>
                <div class="f5 ml2">
                  notify the selected action
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> dnd_action <span class="green">/* action selected by the compositor */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">This event indicates the action selected by the compositor after
matching the source&#x2f;destination side actions. Only one action (or
none) will be offered here.

This event can be emitted multiple times during the drag-and-drop
operation, mainly in response to destination side changes through
wl_data_offer.set_actions, and as the data device enters&#x2f;leaves
surfaces.

It is only possible to receive this event after
wl_data_source.dnd_drop_performed if the drag-and-drop operation
ended in an &quot;ask&quot; action, in which case the final wl_data_source.action
event will happen immediately before wl_data_source.dnd_finished.

Compositors may also change the selected action on the fly, mainly
in response to keyboard modifier changes during the drag-and-drop
operation.

The most recent action received is always the valid one. The chosen
action may change alongside negotiation (e.g. an &quot;ask&quot; action can turn
into a &quot;move&quot; operation), so the effects of the final action must
always be applied in wl_data_offer.dnd_finished.

Clients can trigger cursor surface changes from this point, so
they reflect the current action.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_data_device">
          <a href="#i:wl_data_device" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_data_device
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">There is one wl_data_device per seat which can be obtained
from the global wl_data_device_manager singleton.

A wl_data_device provides access to inter-client data transfer
mechanisms such as copy-and-paste and drag-and-drop.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_data_device">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_data_device:start_drag">
                <a href="#r:wl_data_device:start_drag" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  start_drag
                </div>
                <div class="f5 ml2">
                  start drag-and-drop operation
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_data_device_start_drag</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_device*</span> wl_data_device,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_source*</span> source, <span class="green">/* data source for the eventual transfer */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> origin, <span class="green">/* surface where the drag originates */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> icon, <span class="green">/* drag-and-drop icon surface */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the implicit grab on the origin */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">This request asks the compositor to start a drag-and-drop
operation on behalf of the client.

The source argument is the data source that provides the data
for the eventual data transfer. If source is NULL, enter, leave
and motion events are sent only to the client that initiated the
drag and the client is expected to handle the data passing
internally. If source is destroyed, the drag-and-drop session will be
cancelled.

The origin surface is the surface where the drag originates and
the client must have an active implicit grab that matches the
serial.

The icon surface is an optional (can be NULL) surface that
provides an icon to be moved around with the cursor.  Initially,
the top-left corner of the icon surface is placed at the cursor
hotspot, but subsequent wl_surface.attach request can move the
relative position. Attach requests must be confirmed with
wl_surface.commit as usual. The icon surface is given the role of
a drag-and-drop icon. If the icon surface already has another role,
it raises a protocol error.

The current and pending input regions of the icon wl_surface are
cleared, and wl_surface.set_input_region is ignored until the
wl_surface is no longer used as the icon surface. When the use
as an icon ends, the current and pending input regions become
undefined, and the wl_surface is unmapped.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_data_device:set_selection">
                <a href="#r:wl_data_device:set_selection" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_selection
                </div>
                <div class="f5 ml2">
                  copy data to the selection
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_data_device_set_selection</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_device*</span> wl_data_device,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_source*</span> source, <span class="green">/* data source for the selection */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the event that triggered this request */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">This request asks the compositor to set the selection
to the data from the source on behalf of the client.

To unset the selection, set the source to NULL.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_data_device:release">
                <a href="#r:wl_data_device:release" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  release
                </div>
                <div class="f5 ml2">
                  destroy data device
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_data_device_release</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_device*</span> wl_data_device</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">This request destroys the data device.
  </div>
            </li>
            
          </ul>
        

        
          <h3 class=" f5 lh-title" id="eh:wl_data_device">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_device:data_offer">
                <a href="#e:wl_data_device:data_offer" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  data_offer
                </div>
                <div class="f5 ml2">
                  introduce a new wl_data_offer
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">struct wl_data_offer*</span> id <span class="green">/* the new data_offer object */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">The data_offer event introduces a new wl_data_offer object,
which will subsequently be used in either the
data_device.enter event (for drag-and-drop) or the
data_device.selection event (for selections).  Immediately
following the data_device_data_offer event, the new data_offer
object will send out data_offer.offer events to describe the
mime types it offers.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_device:enter">
                <a href="#e:wl_data_device:enter" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  enter
                </div>
                <div class="f5 ml2">
                  initiate drag-and-drop session
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the enter event */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">struct wl_surface*</span> surface <span class="green">/* client surface entered */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> x <span class="green">/* surface-local x coordinate */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> y <span class="green">/* surface-local y coordinate */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">struct wl_data_offer*</span> id <span class="green">/* source data_offer object */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">This event is sent when an active drag-and-drop pointer enters
a surface owned by the client.  The position of the pointer at
enter time is provided by the x and y arguments, in surface-local
coordinates.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_device:leave">
                <a href="#e:wl_data_device:leave" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  leave
                </div>
                <div class="f5 ml2">
                  end drag-and-drop session
                </div>
              </div>

              

              <div class="f6 lh-copy ws-pre-line courier mt2">This event is sent when the drag-and-drop pointer leaves the
surface and the session ends.  The client must destroy the
wl_data_offer introduced at enter time at this point.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_device:motion">
                <a href="#e:wl_data_device:motion" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  motion
                </div>
                <div class="f5 ml2">
                  drag-and-drop session motion
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> time <span class="green">/* timestamp with millisecond granularity */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> x <span class="green">/* surface-local x coordinate */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> y <span class="green">/* surface-local y coordinate */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">This event is sent when the drag-and-drop pointer moves within
the currently focused surface. The new position of the pointer
is provided by the x and y arguments, in surface-local
coordinates.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_device:drop">
                <a href="#e:wl_data_device:drop" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  drop
                </div>
                <div class="f5 ml2">
                  end drag-and-drop session successfully
                </div>
              </div>

              

              <div class="f6 lh-copy ws-pre-line courier mt2">The event is sent when a drag-and-drop operation is ended
because the implicit grab is removed.

The drag-and-drop destination is expected to honor the last action
received through wl_data_offer.action, if the resulting action is
&quot;copy&quot; or &quot;move&quot;, the destination can still perform
wl_data_offer.receive requests, and is expected to end all
transfers with a wl_data_offer.finish request.

If the resulting action is &quot;ask&quot;, the action will not be considered
final. The drag-and-drop destination is expected to perform one last
wl_data_offer.set_actions request, or wl_data_offer.destroy in order
to cancel the operation.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_data_device:selection">
                <a href="#e:wl_data_device:selection" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  selection
                </div>
                <div class="f5 ml2">
                  advertise new selection
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">struct wl_data_offer*</span> id <span class="green">/* selection data_offer object */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">The selection event is sent out to notify the client of a new
wl_data_offer for the selection for this device.  The
data_device.data_offer and the data_offer.offer events are
sent out immediately before this event to introduce the data
offer object.  The selection event is sent to a client
immediately before receiving keyboard focus and when a new
selection is set while the client has keyboard focus.  The
data_offer is valid until a new data_offer or NULL is received
or until the client loses keyboard focus.  The client must
destroy the previous selection data_offer, if any, upon receiving
this event.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_data_device_manager">
          <a href="#i:wl_data_device_manager" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_data_device_manager
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">The wl_data_device_manager is a singleton global object that
provides access to inter-client data transfer mechanisms such as
copy-and-paste and drag-and-drop.  These mechanisms are tied to
a wl_seat and this interface lets a client get a wl_data_device
corresponding to a wl_seat.

Depending on the version bound, the objects created from the bound
wl_data_device_manager object will have different requirements for
functioning properly. See wl_data_source.set_actions,
wl_data_offer.accept and wl_data_offer.finish for details.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_data_device_manager">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_data_device_manager:create_data_source">
                <a href="#r:wl_data_device_manager:create_data_source" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  create_data_source
                </div>
                <div class="f5 ml2">
                  create a new data source
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>struct wl_data_source* </span><span class="dark-blue">wl_data_device_manager_create_data_source</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_device_manager*</span> wl_data_device_manager</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Create a new data source.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_data_device_manager:get_data_device">
                <a href="#r:wl_data_device_manager:get_data_device" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  get_data_device
                </div>
                <div class="f5 ml2">
                  create a new data device
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>struct wl_data_device* </span><span class="dark-blue">wl_data_device_manager_get_data_device</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_data_device_manager*</span> wl_data_device_manager,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_seat*</span> seat <span class="green">/* seat associated with the data device */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Create a new data device for a given seat.
  </div>
            </li>
            
          </ul>
        

        

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_shell">
          <a href="#i:wl_shell" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_shell
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">This interface is implemented by servers that provide
desktop-style user interfaces.

It allows clients to associate a wl_shell_surface with
a basic surface.

Note! This protocol is deprecated and not intended for production use.
For desktop-style user interfaces, use xdg_shell.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_shell">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shell:get_shell_surface">
                <a href="#r:wl_shell:get_shell_surface" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  get_shell_surface
                </div>
                <div class="f5 ml2">
                  create a shell surface from a surface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>struct wl_shell_surface* </span><span class="dark-blue">wl_shell_get_shell_surface</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shell*</span> wl_shell,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> surface <span class="green">/* surface to be given the shell surface role */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Create a shell surface for an existing surface. This gives
the wl_surface the role of a shell surface. If the wl_surface
already has another role, it raises a protocol error.

Only one shell surface can be associated with a given surface.
  </div>
            </li>
            
          </ul>
        

        

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_shell_surface">
          <a href="#i:wl_shell_surface" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_shell_surface
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">An interface that may be implemented by a wl_surface, for
implementations that provide a desktop-style user interface.

It provides requests to treat surfaces like toplevel, fullscreen
or popup windows, move, resize or maximize them, associate
metadata like title and class, etc.

On the server side the object is automatically destroyed when
the related wl_surface is destroyed. On the client side,
wl_shell_surface_destroy() must be called before destroying
the wl_surface object.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_shell_surface">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shell_surface:pong">
                <a href="#r:wl_shell_surface:pong" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  pong
                </div>
                <div class="f5 ml2">
                  respond to a ping event
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_shell_surface_pong</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shell_surface*</span> wl_shell_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the ping event */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">A client must respond to a ping event with a pong request or
the client may be deemed unresponsive.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shell_surface:move">
                <a href="#r:wl_shell_surface:move" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  move
                </div>
                <div class="f5 ml2">
                  start an interactive move
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_shell_surface_move</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shell_surface*</span> wl_shell_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_seat*</span> seat, <span class="green">/* seat whose pointer is used */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the implicit grab on the pointer */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Start a pointer-driven move of the surface.

This request must be used in response to a button press event.
The server may ignore move requests depending on the state of
the surface (e.g. fullscreen or maximized).
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shell_surface:resize">
                <a href="#r:wl_shell_surface:resize" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  resize
                </div>
                <div class="f5 ml2">
                  start an interactive resize
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_shell_surface_resize</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shell_surface*</span> wl_shell_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_seat*</span> seat, <span class="green">/* seat whose pointer is used */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> serial, <span class="green">/* serial number of the implicit grab on the pointer */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> edges <span class="green">/* which edge or corner is being dragged */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Start a pointer-driven resizing of the surface.

This request must be used in response to a button press event.
The server may ignore resize requests depending on the state of
the surface (e.g. fullscreen or maximized).
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shell_surface:set_toplevel">
                <a href="#r:wl_shell_surface:set_toplevel" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_toplevel
                </div>
                <div class="f5 ml2">
                  make the surface a toplevel surface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_shell_surface_set_toplevel</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shell_surface*</span> wl_shell_surface</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Map the surface as a toplevel surface.

A toplevel surface is not fullscreen, maximized or transient.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shell_surface:set_transient">
                <a href="#r:wl_shell_surface:set_transient" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_transient
                </div>
                <div class="f5 ml2">
                  make the surface a transient surface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_shell_surface_set_transient</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shell_surface*</span> wl_shell_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> parent, <span class="green">/* parent surface */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> x, <span class="green">/* surface-local x coordinate */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> y, <span class="green">/* surface-local y coordinate */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> flags <span class="green">/* transient surface behavior */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Map the surface relative to an existing surface.

The x and y arguments specify the location of the upper left
corner of the surface relative to the upper left corner of the
parent surface, in surface-local coordinates.

The flags argument controls details of the transient behaviour.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shell_surface:set_fullscreen">
                <a href="#r:wl_shell_surface:set_fullscreen" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_fullscreen
                </div>
                <div class="f5 ml2">
                  make the surface a fullscreen surface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_shell_surface_set_fullscreen</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shell_surface*</span> wl_shell_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> method, <span class="green">/* method for resolving size conflict */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> framerate, <span class="green">/* framerate in mHz */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_output*</span> output <span class="green">/* output on which the surface is to be fullscreen */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Map the surface as a fullscreen surface.

If an output parameter is given then the surface will be made
fullscreen on that output. If the client does not specify the
output then the compositor will apply its policy - usually
choosing the output on which the surface has the biggest surface
area.

The client may specify a method to resolve a size conflict
between the output size and the surface size - this is provided
through the method parameter.

The framerate parameter is used only when the method is set
to &quot;driver&quot;, to indicate the preferred framerate. A value of 0
indicates that the client does not care about framerate.  The
framerate is specified in mHz, that is framerate of 60000 is 60Hz.

A method of &quot;scale&quot; or &quot;driver&quot; implies a scaling operation of
the surface, either via a direct scaling operation or a change of
the output mode. This will override any kind of output scaling, so
that mapping a surface with a buffer size equal to the mode can
fill the screen independent of buffer_scale.

A method of &quot;fill&quot; means we don&#x27;t scale up the buffer, however
any output scale is applied. This means that you may run into
an edge case where the application maps a buffer with the same
size of the output mode but buffer_scale 1 (thus making a
surface larger than the output). In this case it is allowed to
downscale the results to fit the screen.

The compositor must reply to this request with a configure event
with the dimensions for the output on which the surface will
be made fullscreen.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shell_surface:set_popup">
                <a href="#r:wl_shell_surface:set_popup" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_popup
                </div>
                <div class="f5 ml2">
                  make the surface a popup surface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_shell_surface_set_popup</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shell_surface*</span> wl_shell_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_seat*</span> seat, <span class="green">/* seat whose pointer is used */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> serial, <span class="green">/* serial number of the implicit grab on the pointer */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> parent, <span class="green">/* parent surface */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> x, <span class="green">/* surface-local x coordinate */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> y, <span class="green">/* surface-local y coordinate */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> flags <span class="green">/* transient surface behavior */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Map the surface as a popup.

A popup surface is a transient surface with an added pointer
grab.

An existing implicit grab will be changed to owner-events mode,
and the popup grab will continue after the implicit grab ends
(i.e. releasing the mouse button does not cause the popup to
be unmapped).

The popup grab continues until the window is destroyed or a
mouse button is pressed in any other client&#x27;s window. A click
in any of the client&#x27;s surfaces is reported as normal, however,
clicks in other clients&#x27; surfaces will be discarded and trigger
the callback.

The x and y arguments specify the location of the upper left
corner of the surface relative to the upper left corner of the
parent surface, in surface-local coordinates.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shell_surface:set_maximized">
                <a href="#r:wl_shell_surface:set_maximized" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_maximized
                </div>
                <div class="f5 ml2">
                  make the surface a maximized surface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_shell_surface_set_maximized</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shell_surface*</span> wl_shell_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_output*</span> output <span class="green">/* output on which the surface is to be maximized */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Map the surface as a maximized surface.

If an output parameter is given then the surface will be
maximized on that output. If the client does not specify the
output then the compositor will apply its policy - usually
choosing the output on which the surface has the biggest surface
area.

The compositor will reply with a configure event telling
the expected new surface size. The operation is completed
on the next buffer attach to this surface.

A maximized surface typically fills the entire output it is
bound to, except for desktop elements such as panels. This is
the main difference between a maximized shell surface and a
fullscreen shell surface.

The details depend on the compositor implementation.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shell_surface:set_title">
                <a href="#r:wl_shell_surface:set_title" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_title
                </div>
                <div class="f5 ml2">
                  set surface title
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_shell_surface_set_title</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shell_surface*</span> wl_shell_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">const char*</span> title <span class="green">/* surface title */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Set a short title for the surface.

This string may be used to identify the surface in a task bar,
window list, or other user interface elements provided by the
compositor.

The string must be encoded in UTF-8.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_shell_surface:set_class">
                <a href="#r:wl_shell_surface:set_class" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_class
                </div>
                <div class="f5 ml2">
                  set surface class
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_shell_surface_set_class</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_shell_surface*</span> wl_shell_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">const char*</span> class_ <span class="green">/* surface class */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Set a class for the surface.

The surface class identifies the general class of applications
to which the surface belongs. A common convention is to use the
file name (or the full path if it is a non-standard location) of
the application&#x27;s .desktop file as the class.
  </div>
            </li>
            
          </ul>
        

        
          <h3 class=" f5 lh-title" id="eh:wl_shell_surface">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_shell_surface:ping">
                <a href="#e:wl_shell_surface:ping" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  ping
                </div>
                <div class="f5 ml2">
                  ping client
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the ping */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Ping a client to check if it is receiving events and sending
requests. A client is expected to reply with a pong request.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_shell_surface:configure">
                <a href="#e:wl_shell_surface:configure" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  configure
                </div>
                <div class="f5 ml2">
                  suggest resize
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> edges <span class="green">/* how the surface was resized */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> width <span class="green">/* new width of the surface */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> height <span class="green">/* new height of the surface */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">The configure event asks the client to resize its surface.

The size is a hint, in the sense that the client is free to
ignore it if it doesn&#x27;t resize, pick a smaller size (to
satisfy aspect ratio or resize in steps of NxM pixels).

The edges parameter provides a hint about how the surface
was resized. The client may use this information to decide
how to adjust its content to the new size (e.g. a scrolling
area might adjust its content position to leave the viewable
content unmoved).

The client is free to dismiss all but the last configure
event it received.

The width and height arguments specify the size of the window
in surface-local coordinates.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_shell_surface:popup_done">
                <a href="#e:wl_shell_surface:popup_done" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  popup_done
                </div>
                <div class="f5 ml2">
                  popup interaction is done
                </div>
              </div>

              

              <div class="f6 lh-copy ws-pre-line courier mt2">The popup_done event is sent out when a popup grab is broken,
that is, when the user clicks a surface that doesn&#x27;t belong
to the client owning the popup surface.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_surface">
          <a href="#i:wl_surface" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_surface
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">A surface is a rectangular area that may be displayed on zero
or more outputs, and shown any number of times at the compositor&#x27;s
discretion. They can present wl_buffers, receive user input, and
define a local coordinate system.

The size of a surface (and relative positions on it) is described
in surface-local coordinates, which may differ from the buffer
coordinates of the pixel content, in case a buffer_transform
or a buffer_scale is used.

A surface without a &quot;role&quot; is fairly useless: a compositor does
not know where, when or how to present it. The role is the
purpose of a wl_surface. Examples of roles are a cursor for a
pointer (as set by wl_pointer.set_cursor), a drag icon
(wl_data_device.start_drag), a sub-surface
(wl_subcompositor.get_subsurface), and a window as defined by a
shell protocol (e.g. wl_shell.get_shell_surface).

A surface can have only one role at a time. Initially a
wl_surface does not have a role. Once a wl_surface is given a
role, it is set permanently for the whole lifetime of the
wl_surface object. Giving the current role again is allowed,
unless explicitly forbidden by the relevant interface
specification.

Surface roles are given by requests in other interfaces such as
wl_pointer.set_cursor. The request should explicitly mention
that this request gives a role to a wl_surface. Often, this
request also creates a new protocol object that represents the
role and adds additional functionality to wl_surface. When a
client wants to destroy a wl_surface, they must destroy this &#x27;role
object&#x27; before the wl_surface.

Destroying the role object does not remove the role from the
wl_surface, but it may stop the wl_surface from &quot;playing the role&quot;.
For instance, if a wl_subsurface object is destroyed, the wl_surface
it was created for will be unmapped and forget its position and
z-order. It is allowed to create a wl_subsurface for the same
wl_surface again, but it is not allowed to use the wl_surface as
a cursor (cursor is a different role than sub-surface, and role
switching is not allowed).
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_surface">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_surface:destroy">
                <a href="#r:wl_surface:destroy" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  destroy
                </div>
                <div class="f5 ml2">
                  delete surface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_surface_destroy</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> wl_surface</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Deletes the surface and invalidates its object ID.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_surface:attach">
                <a href="#r:wl_surface:attach" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  attach
                </div>
                <div class="f5 ml2">
                  set the surface contents
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_surface_attach</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> wl_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_buffer*</span> buffer, <span class="green">/* buffer of surface contents */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> x, <span class="green">/* surface-local x coordinate */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> y <span class="green">/* surface-local y coordinate */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Set a buffer as the content of this surface.

The new size of the surface is calculated based on the buffer
size transformed by the inverse buffer_transform and the
inverse buffer_scale. This means that at commit time the supplied
buffer size must be an integer multiple of the buffer_scale. If
that&#x27;s not the case, an invalid_size error is sent.

The x and y arguments specify the location of the new pending
buffer&#x27;s upper left corner, relative to the current buffer&#x27;s upper
left corner, in surface-local coordinates. In other words, the
x and y, combined with the new surface size define in which
directions the surface&#x27;s size changes.

Surface contents are double-buffered state, see wl_surface.commit.

The initial surface contents are void; there is no content.
wl_surface.attach assigns the given wl_buffer as the pending
wl_buffer. wl_surface.commit makes the pending wl_buffer the new
surface contents, and the size of the surface becomes the size
calculated from the wl_buffer, as described above. After commit,
there is no pending buffer until the next attach.

Committing a pending wl_buffer allows the compositor to read the
pixels in the wl_buffer. The compositor may access the pixels at
any time after the wl_surface.commit request. When the compositor
will not access the pixels anymore, it will send the
wl_buffer.release event. Only after receiving wl_buffer.release,
the client may reuse the wl_buffer. A wl_buffer that has been
attached and then replaced by another attach instead of committed
will not receive a release event, and is not used by the
compositor.

If a pending wl_buffer has been committed to more than one wl_surface,
the delivery of wl_buffer.release events becomes undefined. A well
behaved client should not rely on wl_buffer.release events in this
case. Alternatively, a client could create multiple wl_buffer objects
from the same backing storage or use wp_linux_buffer_release.

Destroying the wl_buffer after wl_buffer.release does not change
the surface contents. However, if the client destroys the
wl_buffer before receiving the wl_buffer.release event, the surface
contents become undefined immediately.

If wl_surface.attach is sent with a NULL wl_buffer, the
following wl_surface.commit will remove the surface content.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_surface:damage">
                <a href="#r:wl_surface:damage" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  damage
                </div>
                <div class="f5 ml2">
                  mark part of the surface damaged
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_surface_damage</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> wl_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> x, <span class="green">/* surface-local x coordinate */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> y, <span class="green">/* surface-local y coordinate */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> width, <span class="green">/* width of damage rectangle */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> height <span class="green">/* height of damage rectangle */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">This request is used to describe the regions where the pending
buffer is different from the current surface contents, and where
the surface therefore needs to be repainted. The compositor
ignores the parts of the damage that fall outside of the surface.

Damage is double-buffered state, see wl_surface.commit.

The damage rectangle is specified in surface-local coordinates,
where x and y specify the upper left corner of the damage rectangle.

The initial value for pending damage is empty: no damage.
wl_surface.damage adds pending damage: the new pending damage
is the union of old pending damage and the given rectangle.

wl_surface.commit assigns pending damage as the current damage,
and clears pending damage. The server will clear the current
damage as it repaints the surface.

Note! New clients should not use this request. Instead damage can be
posted with wl_surface.damage_buffer which uses buffer coordinates
instead of surface coordinates.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_surface:frame">
                <a href="#r:wl_surface:frame" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  frame
                </div>
                <div class="f5 ml2">
                  request a frame throttling hint
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>struct wl_callback* </span><span class="dark-blue">wl_surface_frame</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> wl_surface</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Request a notification when it is a good time to start drawing a new
frame, by creating a frame callback. This is useful for throttling
redrawing operations, and driving animations.

When a client is animating on a wl_surface, it can use the &#x27;frame&#x27;
request to get notified when it is a good time to draw and commit the
next frame of animation. If the client commits an update earlier than
that, it is likely that some updates will not make it to the display,
and the client is wasting resources by drawing too often.

The frame request will take effect on the next wl_surface.commit.
The notification will only be posted for one frame unless
requested again. For a wl_surface, the notifications are posted in
the order the frame requests were committed.

The server must send the notifications so that a client
will not send excessive updates, while still allowing
the highest possible update rate for clients that wait for the reply
before drawing again. The server should give some time for the client
to draw and commit after sending the frame callback events to let it
hit the next output refresh.

A server should avoid signaling the frame callbacks if the
surface is not visible in any way, e.g. the surface is off-screen,
or completely obscured by other opaque surfaces.

The object returned by this request will be destroyed by the
compositor after the callback is fired and as such the client must not
attempt to use it after that point.

The callback_data passed in the callback is the current time, in
milliseconds, with an undefined base.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_surface:set_opaque_region">
                <a href="#r:wl_surface:set_opaque_region" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_opaque_region
                </div>
                <div class="f5 ml2">
                  set opaque region
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_surface_set_opaque_region</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> wl_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_region*</span> region <span class="green">/* opaque region of the surface */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">This request sets the region of the surface that contains
opaque content.

The opaque region is an optimization hint for the compositor
that lets it optimize the redrawing of content behind opaque
regions.  Setting an opaque region is not required for correct
behaviour, but marking transparent content as opaque will result
in repaint artifacts.

The opaque region is specified in surface-local coordinates.

The compositor ignores the parts of the opaque region that fall
outside of the surface.

Opaque region is double-buffered state, see wl_surface.commit.

wl_surface.set_opaque_region changes the pending opaque region.
wl_surface.commit copies the pending region to the current region.
Otherwise, the pending and current regions are never changed.

The initial value for an opaque region is empty. Setting the pending
opaque region has copy semantics, and the wl_region object can be
destroyed immediately. A NULL wl_region causes the pending opaque
region to be set to empty.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_surface:set_input_region">
                <a href="#r:wl_surface:set_input_region" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_input_region
                </div>
                <div class="f5 ml2">
                  set input region
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_surface_set_input_region</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> wl_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_region*</span> region <span class="green">/* input region of the surface */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">This request sets the region of the surface that can receive
pointer and touch events.

Input events happening outside of this region will try the next
surface in the server surface stack. The compositor ignores the
parts of the input region that fall outside of the surface.

The input region is specified in surface-local coordinates.

Input region is double-buffered state, see wl_surface.commit.

wl_surface.set_input_region changes the pending input region.
wl_surface.commit copies the pending region to the current region.
Otherwise the pending and current regions are never changed,
except cursor and icon surfaces are special cases, see
wl_pointer.set_cursor and wl_data_device.start_drag.

The initial value for an input region is infinite. That means the
whole surface will accept input. Setting the pending input region
has copy semantics, and the wl_region object can be destroyed
immediately. A NULL wl_region causes the input region to be set
to infinite.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_surface:commit">
                <a href="#r:wl_surface:commit" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  commit
                </div>
                <div class="f5 ml2">
                  commit pending surface state
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_surface_commit</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> wl_surface</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Surface state (input, opaque, and damage regions, attached buffers,
etc.) is double-buffered. Protocol requests modify the pending state,
as opposed to the current state in use by the compositor. A commit
request atomically applies all pending state, replacing the current
state. After commit, the new pending state is as documented for each
related request.

On commit, a pending wl_buffer is applied first, and all other state
second. This means that all coordinates in double-buffered state are
relative to the new wl_buffer coming into use, except for
wl_surface.attach itself. If there is no pending wl_buffer, the
coordinates are relative to the current surface contents.

All requests that need a commit to become effective are documented
to affect double-buffered state.

Other interfaces may add further double-buffered surface state.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_surface:set_buffer_transform">
                <a href="#r:wl_surface:set_buffer_transform" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_buffer_transform
                </div>
                <div class="f5 ml2">
                  sets the buffer transformation
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_surface_set_buffer_transform</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> wl_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> transform <span class="green">/* transform for interpreting buffer contents */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">This request sets an optional transformation on how the compositor
interprets the contents of the buffer attached to the surface. The
accepted values for the transform parameter are the values for
wl_output.transform.

Buffer transform is double-buffered state, see wl_surface.commit.

A newly created surface has its buffer transformation set to normal.

wl_surface.set_buffer_transform changes the pending buffer
transformation. wl_surface.commit copies the pending buffer
transformation to the current one. Otherwise, the pending and current
values are never changed.

The purpose of this request is to allow clients to render content
according to the output transform, thus permitting the compositor to
use certain optimizations even if the display is rotated. Using
hardware overlays and scanning out a client buffer for fullscreen
surfaces are examples of such optimizations. Those optimizations are
highly dependent on the compositor implementation, so the use of this
request should be considered on a case-by-case basis.

Note that if the transform value includes 90 or 270 degree rotation,
the width of the buffer will become the surface height and the height
of the buffer will become the surface width.

If transform is not one of the values from the
wl_output.transform enum the invalid_transform protocol error
is raised.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_surface:set_buffer_scale">
                <a href="#r:wl_surface:set_buffer_scale" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_buffer_scale
                </div>
                <div class="f5 ml2">
                  sets the buffer scaling factor
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_surface_set_buffer_scale</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> wl_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> scale <span class="green">/* positive scale for interpreting buffer contents */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">This request sets an optional scaling factor on how the compositor
interprets the contents of the buffer attached to the window.

Buffer scale is double-buffered state, see wl_surface.commit.

A newly created surface has its buffer scale set to 1.

wl_surface.set_buffer_scale changes the pending buffer scale.
wl_surface.commit copies the pending buffer scale to the current one.
Otherwise, the pending and current values are never changed.

The purpose of this request is to allow clients to supply higher
resolution buffer data for use on high resolution outputs. It is
intended that you pick the same buffer scale as the scale of the
output that the surface is displayed on. This means the compositor
can avoid scaling when rendering the surface on that output.

Note that if the scale is larger than 1, then you have to attach
a buffer that is larger (by a factor of scale in each dimension)
than the desired surface size.

If scale is not positive the invalid_scale protocol error is
raised.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_surface:damage_buffer">
                <a href="#r:wl_surface:damage_buffer" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  damage_buffer
                </div>
                <div class="f5 ml2">
                  mark part of the surface damaged using buffer coordinates
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_surface_damage_buffer</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> wl_surface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> x, <span class="green">/* buffer-local x coordinate */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> y, <span class="green">/* buffer-local y coordinate */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> width, <span class="green">/* width of damage rectangle */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> height <span class="green">/* height of damage rectangle */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">This request is used to describe the regions where the pending
buffer is different from the current surface contents, and where
the surface therefore needs to be repainted. The compositor
ignores the parts of the damage that fall outside of the surface.

Damage is double-buffered state, see wl_surface.commit.

The damage rectangle is specified in buffer coordinates,
where x and y specify the upper left corner of the damage rectangle.

The initial value for pending damage is empty: no damage.
wl_surface.damage_buffer adds pending damage: the new pending
damage is the union of old pending damage and the given rectangle.

wl_surface.commit assigns pending damage as the current damage,
and clears pending damage. The server will clear the current
damage as it repaints the surface.

This request differs from wl_surface.damage in only one way - it
takes damage in buffer coordinates instead of surface-local
coordinates. While this generally is more intuitive than surface
coordinates, it is especially desirable when using wp_viewport
or when a drawing library (like EGL) is unaware of buffer scale
and buffer transform.

Note: Because buffer transformation changes and damage requests may
be interleaved in the protocol stream, it is impossible to determine
the actual mapping between surface and buffer damage until
wl_surface.commit time. Therefore, compositors wishing to take both
kinds of damage into account will have to accumulate damage from the
two requests separately and only transform from one to the other
after receiving the wl_surface.commit.
  </div>
            </li>
            
          </ul>
        

        
          <h3 class=" f5 lh-title" id="eh:wl_surface">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_surface:enter">
                <a href="#e:wl_surface:enter" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  enter
                </div>
                <div class="f5 ml2">
                  surface enters an output
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">struct wl_output*</span> output <span class="green">/* output entered by the surface */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">This is emitted whenever a surface&#x27;s creation, movement, or resizing
results in some part of it being within the scanout region of an
output.

Note that a surface may be overlapping with zero or more outputs.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_surface:leave">
                <a href="#e:wl_surface:leave" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  leave
                </div>
                <div class="f5 ml2">
                  surface leaves an output
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">struct wl_output*</span> output <span class="green">/* output left by the surface */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">This is emitted whenever a surface&#x27;s creation, movement, or resizing
results in it no longer having any part of it within the scanout region
of an output.

Clients should not use the number of outputs the surface is on for frame
throttling purposes. The surface might be hidden even if no leave event
has been sent, and the compositor might expect new surface content
updates even if no enter event has been sent. The frame event should be
used instead.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_seat">
          <a href="#i:wl_seat" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_seat
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">A seat is a group of keyboards, pointer and touch devices. This
object is published as a global during start up, or when such a
device is hot plugged.  A seat typically has a pointer and
maintains a keyboard focus and a pointer focus.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_seat">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_seat:get_pointer">
                <a href="#r:wl_seat:get_pointer" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  get_pointer
                </div>
                <div class="f5 ml2">
                  return pointer object
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>struct wl_pointer* </span><span class="dark-blue">wl_seat_get_pointer</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_seat*</span> wl_seat</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">The ID provided will be initialized to the wl_pointer interface
for this seat.

This request only takes effect if the seat has the pointer
capability, or has had the pointer capability in the past.
It is a protocol violation to issue this request on a seat that has
never had the pointer capability. The missing_capability error will
be sent in this case.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_seat:get_keyboard">
                <a href="#r:wl_seat:get_keyboard" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  get_keyboard
                </div>
                <div class="f5 ml2">
                  return keyboard object
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>struct wl_keyboard* </span><span class="dark-blue">wl_seat_get_keyboard</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_seat*</span> wl_seat</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">The ID provided will be initialized to the wl_keyboard interface
for this seat.

This request only takes effect if the seat has the keyboard
capability, or has had the keyboard capability in the past.
It is a protocol violation to issue this request on a seat that has
never had the keyboard capability. The missing_capability error will
be sent in this case.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_seat:get_touch">
                <a href="#r:wl_seat:get_touch" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  get_touch
                </div>
                <div class="f5 ml2">
                  return touch object
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>struct wl_touch* </span><span class="dark-blue">wl_seat_get_touch</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_seat*</span> wl_seat</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">The ID provided will be initialized to the wl_touch interface
for this seat.

This request only takes effect if the seat has the touch
capability, or has had the touch capability in the past.
It is a protocol violation to issue this request on a seat that has
never had the touch capability. The missing_capability error will
be sent in this case.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_seat:release">
                <a href="#r:wl_seat:release" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  release
                </div>
                <div class="f5 ml2">
                  release the seat object
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_seat_release</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_seat*</span> wl_seat</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Using this request a client can tell the server that it is not going to
use the seat object anymore.
  </div>
            </li>
            
          </ul>
        

        
          <h3 class=" f5 lh-title" id="eh:wl_seat">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_seat:capabilities">
                <a href="#e:wl_seat:capabilities" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  capabilities
                </div>
                <div class="f5 ml2">
                  seat capabilities changed
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> capabilities <span class="green">/* capabilities of the seat */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">This is emitted whenever a seat gains or loses the pointer,
keyboard or touch capabilities.  The argument is a capability
enum containing the complete set of capabilities this seat has.

When the pointer capability is added, a client may create a
wl_pointer object using the wl_seat.get_pointer request. This object
will receive pointer events until the capability is removed in the
future.

When the pointer capability is removed, a client should destroy the
wl_pointer objects associated with the seat where the capability was
removed, using the wl_pointer.release request. No further pointer
events will be received on these objects.

In some compositors, if a seat regains the pointer capability and a
client has a previously obtained wl_pointer object of version 4 or
less, that object may start sending pointer events again. This
behavior is considered a misinterpretation of the intended behavior
and must not be relied upon by the client. wl_pointer objects of
version 5 or later must not send events if created before the most
recent event notifying the client of an added pointer capability.

The above behavior also applies to wl_keyboard and wl_touch with the
keyboard and touch capabilities, respectively.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_seat:name">
                <a href="#e:wl_seat:name" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  name
                </div>
                <div class="f5 ml2">
                  unique identifier for this seat
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">const char*</span> name <span class="green">/* seat identifier */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">In a multiseat configuration this can be used by the client to help
identify which physical devices the seat represents. Based on
the seat configuration used by the compositor.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_pointer">
          <a href="#i:wl_pointer" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_pointer
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">The wl_pointer interface represents one or more input devices,
such as mice, which control the pointer location and pointer_focus
of a seat.

The wl_pointer interface generates motion, enter and leave
events for the surfaces that the pointer is located over,
and button and axis events for button presses, button releases
and scrolling.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_pointer">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_pointer:set_cursor">
                <a href="#r:wl_pointer:set_cursor" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_cursor
                </div>
                <div class="f5 ml2">
                  set the pointer surface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_pointer_set_cursor</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_pointer*</span> wl_pointer,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">uint32_t</span> serial, <span class="green">/* serial number of the enter event */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> surface, <span class="green">/* pointer surface */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> hotspot_x, <span class="green">/* surface-local x coordinate */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> hotspot_y <span class="green">/* surface-local y coordinate */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Set the pointer surface, i.e., the surface that contains the
pointer image (cursor). This request gives the surface the role
of a cursor. If the surface already has another role, it raises
a protocol error.

The cursor actually changes only if the pointer
focus for this device is one of the requesting client&#x27;s surfaces
or the surface parameter is the current pointer surface. If
there was a previous surface set with this request it is
replaced. If surface is NULL, the pointer image is hidden.

The parameters hotspot_x and hotspot_y define the position of
the pointer surface relative to the pointer location. Its
top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
where (x, y) are the coordinates of the pointer location, in
surface-local coordinates.

On surface.attach requests to the pointer surface, hotspot_x
and hotspot_y are decremented by the x and y parameters
passed to the request. Attach must be confirmed by
wl_surface.commit as usual.

The hotspot can also be updated by passing the currently set
pointer surface to this request with new values for hotspot_x
and hotspot_y.

The current and pending input regions of the wl_surface are
cleared, and wl_surface.set_input_region is ignored until the
wl_surface is no longer used as the cursor. When the use as a
cursor ends, the current and pending input regions become
undefined, and the wl_surface is unmapped.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_pointer:release">
                <a href="#r:wl_pointer:release" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  release
                </div>
                <div class="f5 ml2">
                  release the pointer object
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_pointer_release</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_pointer*</span> wl_pointer</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Using this request a client can tell the server that it is not going to
use the pointer object anymore.

This request destroys the pointer proxy object, so clients must not call
wl_pointer_destroy() after using this request.
  </div>
            </li>
            
          </ul>
        

        
          <h3 class=" f5 lh-title" id="eh:wl_pointer">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_pointer:enter">
                <a href="#e:wl_pointer:enter" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  enter
                </div>
                <div class="f5 ml2">
                  enter event
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the enter event */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">struct wl_surface*</span> surface <span class="green">/* surface entered by the pointer */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> surface_x <span class="green">/* surface-local x coordinate */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> surface_y <span class="green">/* surface-local y coordinate */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Notification that this seat&#x27;s pointer is focused on a certain
surface.

When a seat&#x27;s focus enters a surface, the pointer image
is undefined and a client should respond to this event by setting
an appropriate pointer image with the set_cursor request.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_pointer:leave">
                <a href="#e:wl_pointer:leave" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  leave
                </div>
                <div class="f5 ml2">
                  leave event
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the leave event */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">struct wl_surface*</span> surface <span class="green">/* surface left by the pointer */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Notification that this seat&#x27;s pointer is no longer focused on
a certain surface.

The leave notification is sent before the enter notification
for the new focus.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_pointer:motion">
                <a href="#e:wl_pointer:motion" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  motion
                </div>
                <div class="f5 ml2">
                  pointer motion event
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> time <span class="green">/* timestamp with millisecond granularity */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> surface_x <span class="green">/* surface-local x coordinate */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> surface_y <span class="green">/* surface-local y coordinate */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Notification of pointer location change. The arguments
surface_x and surface_y are the location relative to the
focused surface.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_pointer:button">
                <a href="#e:wl_pointer:button" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  button
                </div>
                <div class="f5 ml2">
                  pointer button event
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the button event */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> time <span class="green">/* timestamp with millisecond granularity */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> button <span class="green">/* button that produced the event */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> state <span class="green">/* physical state of the button */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Mouse button click and release notifications.

The location of the click is given by the last motion or
enter event.
The time argument is a timestamp with millisecond
granularity, with an undefined base.

The button is a button code as defined in the Linux kernel&#x27;s
linux&#x2f;input-event-codes.h header file, e.g. BTN_LEFT.

Any 16-bit button code value is reserved for future additions to the
kernel&#x27;s event code list. All other button codes above 0xFFFF are
currently undefined but may be used in future versions of this
protocol.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_pointer:axis">
                <a href="#e:wl_pointer:axis" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  axis
                </div>
                <div class="f5 ml2">
                  axis event
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> time <span class="green">/* timestamp with millisecond granularity */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> axis <span class="green">/* axis type */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> value <span class="green">/* length of vector in surface-local coordinate space */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Scroll and other axis notifications.

For scroll events (vertical and horizontal scroll axes), the
value parameter is the length of a vector along the specified
axis in a coordinate space identical to those of motion events,
representing a relative movement along the specified axis.

For devices that support movements non-parallel to axes multiple
axis events will be emitted.

When applicable, for example for touch pads, the server can
choose to emit scroll events where the motion vector is
equivalent to a motion event vector.

When applicable, a client can transform its content relative to the
scroll distance.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_pointer:frame">
                <a href="#e:wl_pointer:frame" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  frame
                </div>
                <div class="f5 ml2">
                  end of a pointer event sequence
                </div>
              </div>

              

              <div class="f6 lh-copy ws-pre-line courier mt2">Indicates the end of a set of events that logically belong together.
A client is expected to accumulate the data in all events within the
frame before proceeding.

All wl_pointer events before a wl_pointer.frame event belong
logically together. For example, in a diagonal scroll motion the
compositor will send an optional wl_pointer.axis_source event, two
wl_pointer.axis events (horizontal and vertical) and finally a
wl_pointer.frame event. The client may use this information to
calculate a diagonal vector for scrolling.

When multiple wl_pointer.axis events occur within the same frame,
the motion vector is the combined motion of all events.
When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
the same frame, this indicates that axis movement in one axis has
stopped but continues in the other axis.
When multiple wl_pointer.axis_stop events occur within the same
frame, this indicates that these axes stopped in the same instance.

A wl_pointer.frame event is sent for every logical event group,
even if the group only contains a single wl_pointer event.
Specifically, a client may get a sequence: motion, frame, button,
frame, axis, frame, axis_stop, frame.

The wl_pointer.enter and wl_pointer.leave events are logical events
generated by the compositor and not the hardware. These events are
also grouped by a wl_pointer.frame. When a pointer moves from one
surface to another, a compositor should group the
wl_pointer.leave event within the same wl_pointer.frame.
However, a client must not rely on wl_pointer.leave and
wl_pointer.enter being in the same wl_pointer.frame.
Compositor-specific policies may require the wl_pointer.leave and
wl_pointer.enter event being split across multiple wl_pointer.frame
groups.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_pointer:axis_source">
                <a href="#e:wl_pointer:axis_source" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  axis_source
                </div>
                <div class="f5 ml2">
                  axis source event
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> axis_source <span class="green">/* source of the axis event */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Source information for scroll and other axes.

This event does not occur on its own. It is sent before a
wl_pointer.frame event and carries the source information for
all events within that frame.

The source specifies how this event was generated. If the source is
wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
sent when the user lifts the finger off the device.

If the source is wl_pointer.axis_source.wheel,
wl_pointer.axis_source.wheel_tilt or
wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
or may not be sent. Whether a compositor sends an axis_stop event
for these sources is hardware-specific and implementation-dependent;
clients must not rely on receiving an axis_stop event for these
scroll sources and should treat scroll sequences from these scroll
sources as unterminated by default.

This event is optional. If the source is unknown for a particular
axis event sequence, no event is sent.
Only one wl_pointer.axis_source event is permitted per frame.

The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
not guaranteed.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_pointer:axis_stop">
                <a href="#e:wl_pointer:axis_stop" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  axis_stop
                </div>
                <div class="f5 ml2">
                  axis stop event
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> time <span class="green">/* timestamp with millisecond granularity */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> axis <span class="green">/* the axis stopped with this event */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Stop notification for scroll and other axes.

For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
is sent to notify a client that the axis sequence has terminated.
This enables the client to implement kinetic scrolling.
See the wl_pointer.axis_source documentation for information on when
this event may be generated.

Any wl_pointer.axis events with the same axis_source after this
event should be considered as the start of a new axis motion.

The timestamp is to be interpreted identical to the timestamp in the
wl_pointer.axis event. The timestamp value may be the same as a
preceding wl_pointer.axis event.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_pointer:axis_discrete">
                <a href="#e:wl_pointer:axis_discrete" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  axis_discrete
                </div>
                <div class="f5 ml2">
                  axis click event
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> axis <span class="green">/* axis type */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> discrete <span class="green">/* number of steps */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Discrete step information for scroll and other axes.

This event carries the axis value of the wl_pointer.axis event in
discrete steps (e.g. mouse wheel clicks).

This event does not occur on its own, it is coupled with a
wl_pointer.axis event that represents this axis value on a
continuous scale. The protocol guarantees that each axis_discrete
event is always followed by exactly one axis event with the same
axis number within the same wl_pointer.frame. Note that the protocol
allows for other events to occur between the axis_discrete and
its coupled axis event, including other axis_discrete or axis
events.

This event is optional; continuous scrolling devices
like two-finger scrolling on touchpads do not have discrete
steps and do not generate this event.

The discrete value carries the directional information. e.g. a value
of -2 is two steps towards the negative direction of this axis.

The axis number is identical to the axis number in the associated
axis event.

The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
not guaranteed.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_keyboard">
          <a href="#i:wl_keyboard" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_keyboard
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">The wl_keyboard interface represents one or more keyboards
associated with a seat.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_keyboard">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_keyboard:release">
                <a href="#r:wl_keyboard:release" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  release
                </div>
                <div class="f5 ml2">
                  release the keyboard object
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_keyboard_release</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_keyboard*</span> wl_keyboard</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier"></div>
            </li>
            
          </ul>
        

        
          <h3 class=" f5 lh-title" id="eh:wl_keyboard">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_keyboard:keymap">
                <a href="#e:wl_keyboard:keymap" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  keymap
                </div>
                <div class="f5 ml2">
                  keyboard mapping
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> format <span class="green">/* keymap format */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> fd <span class="green">/* keymap file descriptor */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> size <span class="green">/* keymap size, in bytes */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">This event provides a file descriptor to the client which can be
memory-mapped to provide a keyboard mapping description.

From version 7 onwards, the fd must be mapped with MAP_PRIVATE by
the recipient, as MAP_SHARED may fail.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_keyboard:enter">
                <a href="#e:wl_keyboard:enter" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  enter
                </div>
                <div class="f5 ml2">
                  enter event
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the enter event */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">struct wl_surface*</span> surface <span class="green">/* surface gaining keyboard focus */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">struct wl_array*</span> keys <span class="green">/* the currently pressed keys */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Notification that this seat&#x27;s keyboard focus is on a certain
surface.

The compositor must send the wl_keyboard.modifiers event after this
event.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_keyboard:leave">
                <a href="#e:wl_keyboard:leave" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  leave
                </div>
                <div class="f5 ml2">
                  leave event
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the leave event */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">struct wl_surface*</span> surface <span class="green">/* surface that lost keyboard focus */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Notification that this seat&#x27;s keyboard focus is no longer on
a certain surface.

The leave notification is sent before the enter notification
for the new focus.

After this event client must assume that all keys, including modifiers,
are lifted and also it must stop key repeating if there&#x27;s some going on.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_keyboard:key">
                <a href="#e:wl_keyboard:key" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  key
                </div>
                <div class="f5 ml2">
                  key event
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the key event */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> time <span class="green">/* timestamp with millisecond granularity */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> key <span class="green">/* key that produced the event */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> state <span class="green">/* physical state of the key */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">A key was pressed or released.
The time argument is a timestamp with millisecond
granularity, with an undefined base.

The key is a platform-specific key code that can be interpreted
by feeding it to the keyboard mapping (see the keymap event).

If this event produces a change in modifiers, then the resulting
wl_keyboard.modifiers event must be sent after this event.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_keyboard:modifiers">
                <a href="#e:wl_keyboard:modifiers" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  modifiers
                </div>
                <div class="f5 ml2">
                  modifier and group state
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the modifiers event */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> mods_depressed <span class="green">/* depressed modifiers */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> mods_latched <span class="green">/* latched modifiers */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> mods_locked <span class="green">/* locked modifiers */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> group <span class="green">/* keyboard layout */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Notifies clients that the modifier and&#x2f;or group state has
changed, and it should update its local state.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_keyboard:repeat_info">
                <a href="#e:wl_keyboard:repeat_info" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  repeat_info
                </div>
                <div class="f5 ml2">
                  repeat rate and delay
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">int32_t</span> rate <span class="green">/* the rate of repeating keys in characters per second */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> delay <span class="green">/* delay in milliseconds since key down until repeating starts */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Informs the client about the keyboard&#x27;s repeat rate and delay.

This event is sent as soon as the wl_keyboard object has been created,
and is guaranteed to be received by the client before any key press
event.

Negative values for either rate or delay are illegal. A rate of zero
will disable any repeating (regardless of the value of delay).

This event can be sent later on as well with a new value if necessary,
so clients should continue listening for the event past the creation
of wl_keyboard.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_touch">
          <a href="#i:wl_touch" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_touch
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">The wl_touch interface represents a touchscreen
associated with a seat.

Touch interactions can consist of one or more contacts.
For each contact, a series of events is generated, starting
with a down event, followed by zero or more motion events,
and ending with an up event. Events relating to the same
contact point can be identified by the ID of the sequence.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_touch">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_touch:release">
                <a href="#r:wl_touch:release" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  release
                </div>
                <div class="f5 ml2">
                  release the touch object
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_touch_release</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_touch*</span> wl_touch</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier"></div>
            </li>
            
          </ul>
        

        
          <h3 class=" f5 lh-title" id="eh:wl_touch">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_touch:down">
                <a href="#e:wl_touch:down" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  down
                </div>
                <div class="f5 ml2">
                  touch down event and beginning of a touch sequence
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the touch down event */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> time <span class="green">/* timestamp with millisecond granularity */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">struct wl_surface*</span> surface <span class="green">/* surface touched */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> id <span class="green">/* the unique ID of this touch point */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> x <span class="green">/* surface-local x coordinate */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> y <span class="green">/* surface-local y coordinate */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">A new touch point has appeared on the surface. This touch point is
assigned a unique ID. Future events from this touch point reference
this ID. The ID ceases to be valid after a touch up event and may be
reused in the future.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_touch:up">
                <a href="#e:wl_touch:up" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  up
                </div>
                <div class="f5 ml2">
                  end of a touch event sequence
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> serial <span class="green">/* serial number of the touch up event */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">uint32_t</span> time <span class="green">/* timestamp with millisecond granularity */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> id <span class="green">/* the unique ID of this touch point */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">The touch point has disappeared. No further events will be sent for
this touch point and the touch point&#x27;s ID is released and may be
reused in a future touch down event.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_touch:motion">
                <a href="#e:wl_touch:motion" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  motion
                </div>
                <div class="f5 ml2">
                  update of touch point coordinates
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> time <span class="green">/* timestamp with millisecond granularity */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> id <span class="green">/* the unique ID of this touch point */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> x <span class="green">/* surface-local x coordinate */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> y <span class="green">/* surface-local y coordinate */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">A touch point has changed coordinates.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_touch:frame">
                <a href="#e:wl_touch:frame" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  frame
                </div>
                <div class="f5 ml2">
                  end of touch frame event
                </div>
              </div>

              

              <div class="f6 lh-copy ws-pre-line courier mt2">Indicates the end of a set of events that logically belong together.
A client is expected to accumulate the data in all events within the
frame before proceeding.

A wl_touch.frame terminates at least one event but otherwise no
guarantee is provided about the set of events within a frame. A client
must assume that any state not updated in a frame is unchanged from the
previously known state.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_touch:cancel">
                <a href="#e:wl_touch:cancel" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  cancel
                </div>
                <div class="f5 ml2">
                  touch session cancelled
                </div>
              </div>

              

              <div class="f6 lh-copy ws-pre-line courier mt2">Sent if the compositor decides the touch stream is a global
gesture. No further events are sent to the clients from that
particular gesture. Touch cancellation applies to all touch points
currently active on this client&#x27;s surface. The client is
responsible for finalizing the touch points, future touch points on
this surface may reuse the touch point ID.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_touch:shape">
                <a href="#e:wl_touch:shape" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  shape
                </div>
                <div class="f5 ml2">
                  update shape of touch point
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">int32_t</span> id <span class="green">/* the unique ID of this touch point */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> major <span class="green">/* length of the major axis in surface-local coordinates */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> minor <span class="green">/* length of the minor axis in surface-local coordinates */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Sent when a touchpoint has changed its shape.

This event does not occur on its own. It is sent before a
wl_touch.frame event and carries the new shape information for
any previously reported, or new touch points of that frame.

Other events describing the touch point such as wl_touch.down,
wl_touch.motion or wl_touch.orientation may be sent within the
same wl_touch.frame. A client should treat these events as a single
logical touch point update. The order of wl_touch.shape,
wl_touch.orientation and wl_touch.motion is not guaranteed.
A wl_touch.down event is guaranteed to occur before the first
wl_touch.shape event for this touch ID but both events may occur within
the same wl_touch.frame.

A touchpoint shape is approximated by an ellipse through the major and
minor axis length. The major axis length describes the longer diameter
of the ellipse, while the minor axis length describes the shorter
diameter. Major and minor are orthogonal and both are specified in
surface-local coordinates. The center of the ellipse is always at the
touchpoint location as reported by wl_touch.down or wl_touch.move.

This event is only sent by the compositor if the touch device supports
shape reports. The client has to make reasonable assumptions about the
shape if it did not receive this event.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_touch:orientation">
                <a href="#e:wl_touch:orientation" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  orientation
                </div>
                <div class="f5 ml2">
                  update orientation of touch point
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">int32_t</span> id <span class="green">/* the unique ID of this touch point */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">wl_fixed_t</span> orientation <span class="green">/* angle between major axis and positive surface y-axis in degrees */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">Sent when a touchpoint has changed its orientation.

This event does not occur on its own. It is sent before a
wl_touch.frame event and carries the new shape information for
any previously reported, or new touch points of that frame.

Other events describing the touch point such as wl_touch.down,
wl_touch.motion or wl_touch.shape may be sent within the
same wl_touch.frame. A client should treat these events as a single
logical touch point update. The order of wl_touch.shape,
wl_touch.orientation and wl_touch.motion is not guaranteed.
A wl_touch.down event is guaranteed to occur before the first
wl_touch.orientation event for this touch ID but both events may occur
within the same wl_touch.frame.

The orientation describes the clockwise angle of a touchpoint&#x27;s major
axis to the positive surface y-axis and is normalized to the -180 to
+180 degree range. The granularity of orientation depends on the touch
device, some devices only support binary rotation values between 0 and
90 degrees.

This event is only sent by the compositor if the touch device supports
orientation reports.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_output">
          <a href="#i:wl_output" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_output
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">An output describes part of the compositor geometry.  The
compositor works in the &#x27;compositor coordinate system&#x27; and an
output corresponds to a rectangular area in that space that is
actually visible.  This typically corresponds to a monitor that
displays part of the compositor space.  This object is published
as global during start up, or when a monitor is hotplugged.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_output">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_output:release">
                <a href="#r:wl_output:release" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  release
                </div>
                <div class="f5 ml2">
                  release the output object
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_output_release</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_output*</span> wl_output</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Using this request a client can tell the server that it is not going to
use the output object anymore.
  </div>
            </li>
            
          </ul>
        

        
          <h3 class=" f5 lh-title" id="eh:wl_output">Events</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_output:geometry">
                <a href="#e:wl_output:geometry" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  geometry
                </div>
                <div class="f5 ml2">
                  properties of the output
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">int32_t</span> x <span class="green">/* x position within the global compositor space */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> y <span class="green">/* y position within the global compositor space */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> physical_width <span class="green">/* width in millimeters of the output */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> physical_height <span class="green">/* height in millimeters of the output */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> subpixel <span class="green">/* subpixel orientation of the output */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">const char*</span> make <span class="green">/* textual description of the manufacturer */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">const char*</span> model <span class="green">/* textual description of the model */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> transform <span class="green">/* transform that maps framebuffer to output */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">The geometry event describes geometric properties of the output.
The event is sent when binding to the output object and whenever
any of the properties change.

The physical size can be set to zero if it doesn&#x27;t make sense for this
output (e.g. for projectors or virtual outputs).

Note: wl_output only advertises partial information about the output
position and identification. Some compositors, for instance those not
implementing a desktop-style output layout or those exposing virtual
outputs, might fake this information. Instead of using x and y, clients
should use xdg_output.logical_position. Instead of using make and model,
clients should use xdg_output.name and xdg_output.description.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_output:mode">
                <a href="#e:wl_output:mode" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  mode
                </div>
                <div class="f5 ml2">
                  advertise available modes for the output
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">uint32_t</span> flags <span class="green">/* bitfield of mode flags */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> width <span class="green">/* width of the mode in hardware units */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> height <span class="green">/* height of the mode in hardware units */</span> 
                </div>
              
                <div class="courier">
                  <span class="purple">int32_t</span> refresh <span class="green">/* vertical refresh rate in mHz */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">The mode event describes an available mode for the output.

The event is sent when binding to the output object and there
will always be one mode, the current mode.  The event is sent
again if an output changes mode, for the mode that is now
current.  In other words, the current mode is always the last
mode that was received with the current flag set.

Non-current modes are deprecated. A compositor can decide to only
advertise the current mode and never send other modes. Clients
should not rely on non-current modes.

The size of a mode is given in physical hardware units of
the output device. This is not necessarily the same as
the output size in the global compositor space. For instance,
the output may be scaled, as described in wl_output.scale,
or transformed, as described in wl_output.transform. Clients
willing to retrieve the output size in the global compositor
space should use xdg_output.logical_size instead.

The vertical refresh rate can be set to zero if it doesn&#x27;t make
sense for this output (e.g. for virtual outputs).

Clients should not use the refresh rate to schedule frames. Instead,
they should use the wl_surface.frame event or the presentation-time
protocol.

Note: this information is not always meaningful for all outputs. Some
compositors, such as those exposing virtual outputs, might fake the
refresh rate or the size.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_output:done">
                <a href="#e:wl_output:done" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  done
                </div>
                <div class="f5 ml2">
                  sent all information about output
                </div>
              </div>

              

              <div class="f6 lh-copy ws-pre-line courier mt2">This event is sent after all other properties have been
sent after binding to the output object and after any
other property changes done after that. This allows
changes to the output properties to be seen as
atomic, even if they happen via multiple events.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="e:wl_output:scale">
                <a href="#e:wl_output:scale" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  scale
                </div>
                <div class="f5 ml2">
                  output scaling properties
                </div>
              </div>

              
                <div class="courier">
                  <span class="purple">int32_t</span> factor <span class="green">/* scaling factor of output */</span> 
                </div>
              

              <div class="f6 lh-copy ws-pre-line courier mt2">This event contains scaling geometry information
that is not in the geometry event. It may be sent after
binding the output object or if the output scale changes
later. If it is not sent, the client should assume a
scale of 1.

A scale larger than 1 means that the compositor will
automatically scale surface buffers by this amount
when rendering. This is used for very high resolution
displays where applications rendering at the native
resolution would be too small to be legible.

It is intended that scaling aware clients track the
current output of a surface, and if it is on a scaled
output it should use wl_surface.set_buffer_scale with
the scale of the output. That way the compositor can
avoid scaling the surface, and the client can supply
a higher detail image.
  </div>
            </li>
            
          </ul>

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_region">
          <a href="#i:wl_region" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_region
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">A region object describes an area.

Region objects are used to describe the opaque and input
regions of a surface.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_region">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_region:destroy">
                <a href="#r:wl_region:destroy" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  destroy
                </div>
                <div class="f5 ml2">
                  destroy region
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_region_destroy</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_region*</span> wl_region</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Destroy the region.  This will invalidate the object ID.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_region:add">
                <a href="#r:wl_region:add" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  add
                </div>
                <div class="f5 ml2">
                  add rectangle to region
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_region_add</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_region*</span> wl_region,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> x, <span class="green">/* region-local x coordinate */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> y, <span class="green">/* region-local y coordinate */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> width, <span class="green">/* rectangle width */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> height <span class="green">/* rectangle height */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Add the specified rectangle to the region.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_region:subtract">
                <a href="#r:wl_region:subtract" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  subtract
                </div>
                <div class="f5 ml2">
                  subtract rectangle from region
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_region_subtract</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_region*</span> wl_region,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> x, <span class="green">/* region-local x coordinate */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> y, <span class="green">/* region-local y coordinate */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> width, <span class="green">/* rectangle width */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> height <span class="green">/* rectangle height */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Subtract the specified rectangle from the region.
  </div>
            </li>
            
          </ul>
        

        

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_subcompositor">
          <a href="#i:wl_subcompositor" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_subcompositor
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">The global interface exposing sub-surface compositing capabilities.
A wl_surface, that has sub-surfaces associated, is called the
parent surface. Sub-surfaces can be arbitrarily nested and create
a tree of sub-surfaces.

The root surface in a tree of sub-surfaces is the main
surface. The main surface cannot be a sub-surface, because
sub-surfaces must always have a parent.

A main surface with its sub-surfaces forms a (compound) window.
For window management purposes, this set of wl_surface objects is
to be considered as a single window, and it should also behave as
such.

The aim of sub-surfaces is to offload some of the compositing work
within a window from clients to the compositor. A prime example is
a video player with decorations and video in separate wl_surface
objects. This should allow the compositor to pass YUV video buffer
processing to dedicated overlay hardware when possible.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_subcompositor">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_subcompositor:destroy">
                <a href="#r:wl_subcompositor:destroy" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  destroy
                </div>
                <div class="f5 ml2">
                  unbind from the subcompositor interface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_subcompositor_destroy</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_subcompositor*</span> wl_subcompositor</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Informs the server that the client will not be using this
protocol object anymore. This does not affect any other
objects, wl_subsurface objects included.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_subcompositor:get_subsurface">
                <a href="#r:wl_subcompositor:get_subsurface" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  get_subsurface
                </div>
                <div class="f5 ml2">
                  give a surface the role sub-surface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>struct wl_subsurface* </span><span class="dark-blue">wl_subcompositor_get_subsurface</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_subcompositor*</span> wl_subcompositor,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> surface, <span class="green">/* the surface to be turned into a sub-surface */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> parent <span class="green">/* the parent surface */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Create a sub-surface interface for the given surface, and
associate it with the given parent surface. This turns a
plain wl_surface into a sub-surface.

The to-be sub-surface must not already have another role, and it
must not have an existing wl_subsurface object. Otherwise a protocol
error is raised.

Adding sub-surfaces to a parent is a double-buffered operation on the
parent (see wl_surface.commit). The effect of adding a sub-surface
becomes visible on the next time the state of the parent surface is
applied.

This request modifies the behaviour of wl_surface.commit request on
the sub-surface, see the documentation on wl_subsurface interface.
  </div>
            </li>
            
          </ul>
        

        

        

      </li>
      
      <li class="mt4">
        <h2 class="f2 lh-copy hide-child relative flex items-baseline" id="i:wl_subsurface">
          <a href="#i:wl_subsurface" class="link dim black-70 child pr2 absolute left--2">#</a>
          wl_subsurface
        </h2>
        <div class="f6 lh-copy ws-pre-line courier">An additional interface to a wl_surface object, which has been
made a sub-surface. A sub-surface has one parent surface. A
sub-surface&#x27;s size and position are not limited to that of the parent.
Particularly, a sub-surface is not automatically clipped to its
parent&#x27;s area.

A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
and the parent surface is mapped. The order of which one happens
first is irrelevant. A sub-surface is hidden if the parent becomes
hidden, or if a NULL wl_buffer is applied. These rules apply
recursively through the tree of surfaces.

The behaviour of a wl_surface.commit request on a sub-surface
depends on the sub-surface&#x27;s mode. The possible modes are
synchronized and desynchronized, see methods
wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
mode caches the wl_surface state to be applied when the parent&#x27;s
state gets applied, and desynchronized mode applies the pending
wl_surface state directly. A sub-surface is initially in the
synchronized mode.

Sub-surfaces also have another kind of state, which is managed by
wl_subsurface requests, as opposed to wl_surface requests. This
state includes the sub-surface position relative to the parent
surface (wl_subsurface.set_position), and the stacking order of
the parent and its sub-surfaces (wl_subsurface.place_above and
.place_below). This state is applied when the parent surface&#x27;s
wl_surface state is applied, regardless of the sub-surface&#x27;s mode.
As the exception, set_sync and set_desync are effective immediately.

The main surface can be thought to be always in desynchronized mode,
since it does not have a parent in the sub-surfaces sense.

Even if a sub-surface is in desynchronized mode, it will behave as
in synchronized mode, if its parent surface behaves as in
synchronized mode. This rule is applied recursively throughout the
tree of surfaces. This means, that one can set a sub-surface into
synchronized mode, and then assume that all its child and grand-child
sub-surfaces are synchronized, too, without explicitly setting them.

If the wl_surface associated with the wl_subsurface is destroyed, the
wl_subsurface object becomes inert. Note, that destroying either object
takes effect immediately. If you need to synchronize the removal
of a sub-surface to the parent surface update, unmap the sub-surface
first by attaching a NULL wl_buffer, update parent, and then destroy
the sub-surface.

If the parent wl_surface object is destroyed, the sub-surface is
unmapped.
</div>

        
          <h3 class=" f5 lh-title" id="rh:wl_subsurface">Requests</h3>
          <ul class="list pl0">
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_subsurface:destroy">
                <a href="#r:wl_subsurface:destroy" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  destroy
                </div>
                <div class="f5 ml2">
                  remove sub-surface interface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_subsurface_destroy</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_subsurface*</span> wl_subsurface</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">The sub-surface interface is removed from the wl_surface object
that was turned into a sub-surface with a
wl_subcompositor.get_subsurface request. The wl_surface&#x27;s association
to the parent is deleted, and the wl_surface loses its role as
a sub-surface. The wl_surface is unmapped immediately.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_subsurface:set_position">
                <a href="#r:wl_subsurface:set_position" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_position
                </div>
                <div class="f5 ml2">
                  reposition the sub-surface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_subsurface_set_position</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_subsurface*</span> wl_subsurface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> x, <span class="green">/* x coordinate in the parent surface */</span></div>
    
      <div class="ws-pre-wrap">    <span class="purple">int32_t</span> y <span class="green">/* y coordinate in the parent surface */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">This schedules a sub-surface position change.
The sub-surface will be moved so that its origin (top left
corner pixel) will be at the location x, y of the parent surface
coordinate system. The coordinates are not restricted to the parent
surface area. Negative values are allowed.

The scheduled coordinates will take effect whenever the state of the
parent surface is applied. When this happens depends on whether the
parent surface is in synchronized mode or not. See
wl_subsurface.set_sync and wl_subsurface.set_desync for details.

If more than one set_position request is invoked by the client before
the commit of the parent surface, the position of a new request always
replaces the scheduled position from any previous request.

The initial position is 0, 0.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_subsurface:place_above">
                <a href="#r:wl_subsurface:place_above" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  place_above
                </div>
                <div class="f5 ml2">
                  restack the sub-surface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_subsurface_place_above</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_subsurface*</span> wl_subsurface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> sibling <span class="green">/* the reference surface */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">This sub-surface is taken from the stack, and put back just
above the reference surface, changing the z-order of the sub-surfaces.
The reference surface must be one of the sibling surfaces, or the
parent surface. Using any other surface, including this sub-surface,
will cause a protocol error.

The z-order is double-buffered. Requests are handled in order and
applied immediately to a pending state. The final pending state is
copied to the active state the next time the state of the parent
surface is applied. When this happens depends on whether the parent
surface is in synchronized mode or not. See wl_subsurface.set_sync and
wl_subsurface.set_desync for details.

A new sub-surface is initially added as the top-most in the stack
of its siblings and parent.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_subsurface:place_below">
                <a href="#r:wl_subsurface:place_below" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  place_below
                </div>
                <div class="f5 ml2">
                  restack the sub-surface
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_subsurface_place_below</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_subsurface*</span> wl_subsurface,</div>
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_surface*</span> sibling <span class="green">/* the reference surface */</span></div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">The sub-surface is placed just below the reference surface.
See wl_subsurface.place_above.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_subsurface:set_sync">
                <a href="#r:wl_subsurface:set_sync" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_sync
                </div>
                <div class="f5 ml2">
                  set sub-surface to synchronized mode
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_subsurface_set_sync</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_subsurface*</span> wl_subsurface</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Change the commit behaviour of the sub-surface to synchronized
mode, also described as the parent dependent mode.

In synchronized mode, wl_surface.commit on a sub-surface will
accumulate the committed state in a cache, but the state will
not be applied and hence will not change the compositor output.
The cached state is applied to the sub-surface immediately after
the parent surface&#x27;s state is applied. This ensures atomic
updates of the parent and all its synchronized sub-surfaces.
Applying the cached state will invalidate the cache, so further
parent surface commits do not (re-)apply old state.

See wl_subsurface for the recursive effect of this mode.
  </div>
            </li>
            
            <li class="mt3">
              <div class="flex items-baseline lh-title mb2 hide-child relative" id="r:wl_subsurface:set_desync">
                <a href="#r:wl_subsurface:set_desync" class="link dim black-70 child pr1 absolute left--1 hash-link-entry">#</a>
                <div class="f4">
                  set_desync
                </div>
                <div class="f5 ml2">
                  set sub-surface to desynchronized mode
                </div>
              </div>
              
<div class="f6 lh-copy courier">
  <span>void </span><span class="dark-blue">wl_subsurface_set_desync</span>(
    
      <div class="ws-pre-wrap">    <span class="purple">struct wl_subsurface*</span> wl_subsurface</div>
    
  )
</div>
              <div class="f6 lh-copy ws-pre-line courier">Change the commit behaviour of the sub-surface to desynchronized
mode, also described as independent or freely running mode.

In desynchronized mode, wl_surface.commit on a sub-surface will
apply the pending state directly, without caching, as happens
normally with a wl_surface. Calling wl_surface.commit on the
parent surface has no effect on the sub-surface&#x27;s wl_surface
state. This mode allows a sub-surface to be updated on its own.

If cached state exists when wl_surface.commit is called in
desynchronized mode, the pending state is added to the cached
state, and applied as a whole. This invalidates the cache.

Note: even if a sub-surface is set to desynchronized, a parent
sub-surface may override it to behave as synchronized. For details,
see wl_subsurface.

If a surface&#x27;s parent surface behaves as desynchronized, then
the cached state is applied on set_desync.
  </div>
            </li>
            
          </ul>
        

        

        

      </li>
      
    </ul>

    <h2 class="f4 lh-title">Copyright Info</h2>
    <div class="f7 lh-copy ws-pre-line courier">Copyright © 2008-2011 Kristian Høgsberg
Copyright © 2010-2011 Intel Corporation
Copyright © 2012-2013 Collabora, Ltd.

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation files
(the &quot;Software&quot;), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and&#x2f;or sell copies of the Software,
and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice (including the
next paragraph) shall be included in all copies or substantial
portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</div>
  </div>

    </main>

  </body>
</html>